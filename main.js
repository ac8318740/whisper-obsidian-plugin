/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Whisper
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/Timer.ts
var Timer = class {
  constructor() {
    this.startTime = 0;
    this.elapsedTime = 0;
    this.timerInterval = null;
    this.onUpdate = null;
    this.isPaused = false;
    this.pausedTime = 0;
  }
  setOnUpdate(callback) {
    this.onUpdate = callback;
  }
  start() {
    if (!this.timerInterval) {
      this.startTime = Date.now() - this.elapsedTime;
      this.timerInterval = setInterval(() => {
        if (!this.isPaused) {
          this.elapsedTime = Date.now() - this.startTime;
          if (this.onUpdate) {
            this.onUpdate();
          }
        }
      }, 10);
    }
  }
  pause() {
    this.isPaused = true;
    this.pausedTime = this.elapsedTime;
  }
  resume() {
    if (this.isPaused) {
      this.isPaused = false;
      this.startTime = Date.now() - this.pausedTime;
    }
  }
  reset() {
    if (this.timerInterval) {
      clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
    this.startTime = 0;
    this.elapsedTime = 0;
    this.isPaused = false;
    this.pausedTime = 0;
    if (this.onUpdate) {
      this.onUpdate();
    }
  }
  getDisplay() {
    const totalSeconds = Math.floor(this.elapsedTime / 1e3);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
  }
  getFormattedTime() {
    const seconds = Math.floor(this.elapsedTime / 1e3) % 60;
    const minutes = Math.floor(this.elapsedTime / 1e3 / 60) % 60;
    const hours = Math.floor(this.elapsedTime / 1e3 / 60 / 60);
    const pad = (n) => n < 10 ? "0" + n : n;
    return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
  }
};

// src/Controls.ts
var import_obsidian = require("obsidian");

// src/StatusBar.ts
var StatusBar = class {
  constructor(plugin) {
    this.statusBarItem = null;
    this.status = "idle" /* Idle */;
    this.plugin = plugin;
    this.statusBarItem = this.plugin.addStatusBarItem();
    this.updateStatusBarItem();
  }
  updateStatus(status) {
    this.status = status;
    this.updateStatusBarItem();
  }
  updateStatusBarItem() {
    if (this.statusBarItem) {
      switch (this.status) {
        case "recording" /* Recording */:
          this.statusBarItem.textContent = "Recording...";
          this.statusBarItem.style.color = "red";
          break;
        case "paused" /* Paused */:
          this.statusBarItem.textContent = "Recording Paused";
          this.statusBarItem.style.color = "orange";
          break;
        case "processing" /* Processing */:
          this.statusBarItem.textContent = "Processing audio...";
          this.statusBarItem.style.color = "orange";
          break;
        case "idle" /* Idle */:
        default:
          this.statusBarItem.textContent = "Whisper Idle";
          this.statusBarItem.style.color = "green";
          break;
      }
    }
  }
  remove() {
    if (this.statusBarItem) {
      this.statusBarItem.remove();
    }
  }
};

// src/utils.ts
function getBaseFileName(filePath) {
  const fileName = filePath.substring(filePath.lastIndexOf("/") + 1);
  const baseFileName = fileName.substring(0, fileName.lastIndexOf("."));
  return baseFileName;
}
function generateTimestampedFileName(extension) {
  const now = /* @__PURE__ */ new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, "0");
  const day = String(now.getDate()).padStart(2, "0");
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const dateStr = `${year}-${month}-${day}_${hours}-${minutes}`;
  return `${dateStr}${extension ? `.${extension}` : ""}`;
}

// src/Controls.ts
var Controls = class extends import_obsidian.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
    this.containerEl.addClass("recording-controls");
    this.plugin.timer.setOnUpdate(() => {
      this.updateTimerDisplay();
    });
  }
  async startRecording() {
    console.log("start");
    this.plugin.statusBar.updateStatus("recording" /* Recording */);
    await this.plugin.recorder.startRecording();
    this.plugin.timer.start();
    this.resetGUI();
  }
  async pauseRecording() {
    console.log("pausing recording...");
    const currentState = this.plugin.recorder.getRecordingState();
    if (currentState === "recording") {
      await this.plugin.recorder.pauseRecording();
      this.plugin.statusBar.updateStatus("paused" /* Paused */);
      this.plugin.timer.pause();
      this.pauseButton.setIcon("play").setTooltip("Resume recording");
    } else if (currentState === "paused") {
      await this.plugin.recorder.pauseRecording();
      this.plugin.statusBar.updateStatus("recording" /* Recording */);
      this.plugin.timer.resume();
      this.pauseButton.setIcon("pause").setTooltip("Pause recording");
    }
  }
  async stopRecording() {
    var _a2;
    console.log("stopping recording...");
    this.plugin.statusBar.updateStatus("processing" /* Processing */);
    const blob = await this.plugin.recorder.stopRecording();
    this.plugin.timer.reset();
    this.resetGUI();
    const extension = (_a2 = this.plugin.recorder.getMimeType()) == null ? void 0 : _a2.split("/")[1];
    const fileName = generateTimestampedFileName(extension);
    await this.plugin.audioHandler.processAudioChunks(blob, fileName);
    this.plugin.statusBar.updateStatus("idle" /* Idle */);
    this.updateTimerDisplay();
  }
  updateTimerDisplay() {
    if (this.timerDisplay) {
      this.timerDisplay.textContent = this.plugin.timer.getDisplay();
    }
  }
  resetGUI() {
    const status = this.plugin.statusBar.status;
    this.startButton.setDisabled(status === "recording" /* Recording */ || status === "paused" /* Paused */);
    this.pauseButton.setDisabled(status !== "recording" /* Recording */ && status !== "paused" /* Paused */);
    this.stopButton.setDisabled(status !== "recording" /* Recording */ && status !== "paused" /* Paused */);
    if (status === "recording" /* Recording */) {
      this.pauseButton.setIcon("pause").setTooltip("Pause recording");
    } else if (status === "paused" /* Paused */) {
      this.pauseButton.setIcon("play").setTooltip("Resume recording");
    }
  }
  onOpen() {
    var _a2;
    const { contentEl } = this;
    this.timerDisplay = contentEl.createEl("div", {
      cls: "recording-timer",
      text: "00:00"
    });
    const buttonContainer = contentEl.createEl("div", {
      cls: "recording-controls-buttons"
    });
    this.startButton = new import_obsidian.ButtonComponent(buttonContainer).setIcon("play").setTooltip("Start recording").onClick(async () => {
      await this.startRecording();
    });
    this.pauseButton = new import_obsidian.ButtonComponent(buttonContainer).setIcon("pause").setTooltip("Pause recording").setDisabled(true).onClick(async () => {
      await this.pauseRecording();
    });
    this.stopButton = new import_obsidian.ButtonComponent(buttonContainer).setIcon("stop").setTooltip("Stop recording").setDisabled(true).onClick(async () => {
      await this.stopRecording();
    });
    const languageSetting = new import_obsidian.Setting(contentEl).setName("Language").setDesc("Select or enter the language for transcription");
    const languageContainer = languageSetting.controlEl.createDiv();
    languageContainer.style.display = "flex";
    languageContainer.style.gap = "10px";
    languageContainer.style.alignItems = "center";
    const dropdown = languageContainer.createEl("select");
    const commonLanguages = [
      { value: "", label: "Choose language..." },
      { value: "en", label: "English" },
      { value: "es", label: "Spanish" },
      { value: "fr", label: "French" },
      { value: "de", label: "German" },
      { value: "zh", label: "Chinese" }
    ];
    commonLanguages.forEach((lang) => {
      const option = dropdown.createEl("option");
      option.value = lang.value;
      option.text = lang.label;
    });
    dropdown.value = ((_a2 = commonLanguages.find(
      (lang) => lang.value === this.plugin.settings.language
    )) == null ? void 0 : _a2.value) || "";
    const customInput = languageContainer.createEl("input", {
      type: "text",
      placeholder: "Custom language code"
    });
    customInput.style.display = dropdown.value === "" ? "block" : "none";
    customInput.value = commonLanguages.some(
      (lang) => lang.value === this.plugin.settings.language
    ) ? "" : this.plugin.settings.language;
    dropdown.addEventListener("change", async () => {
      const selectedValue = dropdown.value;
      customInput.style.display = selectedValue === "" ? "block" : "none";
      if (selectedValue !== "") {
        this.plugin.settings.language = selectedValue;
        await this.plugin.settingsManager.saveSettings(this.plugin.settings);
      }
    });
    customInput.addEventListener("change", async () => {
      if (customInput.value) {
        this.plugin.settings.language = customInput.value;
        await this.plugin.settingsManager.saveSettings(this.plugin.settings);
      }
    });
    this.resetGUI();
  }
};

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request2, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request2 && (this.request = request2);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request2, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request2, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request2) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request2);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform_default.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform_default.origin),
  platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
) : () => true;

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path) && cookie.push("path=" + path);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request2 = new XMLHttpRequest();
    request2.open(_config.method.toUpperCase(), _config.url, true);
    request2.timeout = _config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config,
        request: request2
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request2
      ));
      request2 = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request2.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request2.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request2.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request2.upload.addEventListener("progress", uploadThrottled);
      request2.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request2.send(requestData || null);
  });
};

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/axios/lib/adapters/fetch.js
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
var test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
var supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils_default.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
      throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
var getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils_default.isBlob(body)) {
    return body.size;
  }
  if (utils_default.isSpecCompliantForm(body)) {
    const _request = new Request(platform_default.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils_default.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
var resolveBodyLength = async (headers, body) => {
  const length = utils_default.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
var fetch_default = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request2;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils_default.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request2 = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request2);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders_default.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request: request2
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request2),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError_default.from(err, err && err.code, config, request2);
  }
});

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: fetch_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/env/data.js
var VERSION = "1.7.9";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    validator_default.assertOptions(config, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request2) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request2);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// src/AudioHandler.ts
var import_obsidian3 = require("obsidian");

// src/SpeakerReviewModal.ts
var import_obsidian2 = require("obsidian");
var SpeakerReviewModal = class extends import_obsidian2.Modal {
  constructor(app, speakerSamples, previousAttempts, currentFile, onSubmit) {
    super(app);
    this.previousAttempts = [];
    this.attendees = [];
    this.speakerSamples = speakerSamples;
    this.previousAttempts = previousAttempts;
    this.currentFile = currentFile;
    this.onSubmit = onSubmit;
    this.loadAttendees();
  }
  async loadAttendees() {
    if (!this.currentFile) {
      console.debug("No current file available");
      return;
    }
    try {
      const cache = this.app.metadataCache.getFileCache(this.currentFile);
      const frontmatter = cache == null ? void 0 : cache.frontmatter;
      console.debug("Frontmatter from API:", frontmatter);
      if (frontmatter) {
        const attendeesList = frontmatter.Attendees || frontmatter.attendees;
        console.debug("Found attendees list:", attendeesList);
        if (Array.isArray(attendeesList)) {
          this.attendees = attendeesList.map((attendee) => {
            if (typeof attendee !== "string") {
              console.debug("Non-string attendee:", attendee);
              return "";
            }
            attendee = attendee.replace(/^["']|["']$/g, "");
            return attendee.replace(/^\[\[(.*?)\]\]$/, "$1");
          }).filter(Boolean);
          console.debug("Processed attendees:", this.attendees);
        } else {
          console.debug("Attendees list is not an array:", attendeesList);
        }
      } else {
        console.debug("No frontmatter found in file");
      }
    } catch (error) {
      console.error("Error loading attendees:", error);
      this.attendees = [];
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.showSpeakerReview();
    this.scope.register([], "Enter", (evt) => {
      const activeElement = document.activeElement;
      if (activeElement instanceof HTMLInputElement) {
        return false;
      }
      const ctaButton = contentEl.querySelector(".mod-cta");
      if (ctaButton instanceof HTMLButtonElement) {
        ctaButton.click();
      }
      return false;
    });
  }
  showSpeakerReview() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Review Speaker Detection" });
    contentEl.createEl("p", { text: "AssemblyAI detected the following speakers. Please review their first utterances:" });
    const samplesContainer = contentEl.createDiv("speaker-samples");
    this.speakerSamples.forEach((sample) => {
      const sampleDiv = samplesContainer.createDiv("speaker-sample");
      const speakerLabel = sampleDiv.createSpan("speaker-label");
      speakerLabel.createEl("strong", { text: sample.speaker });
      const textBlock = sampleDiv.createSpan("speaker-text");
      textBlock.setText(sample.text);
      sampleDiv.style.display = "flex";
      sampleDiv.style.gap = "1em";
      sampleDiv.style.marginBottom = "1em";
      speakerLabel.style.minWidth = "120px";
      speakerLabel.style.flexShrink = "0";
      textBlock.style.flex = "1";
      textBlock.style.paddingLeft = "1em";
      textBlock.style.borderLeft = "1px solid var(--background-modifier-border)";
      textBlock.style.whiteSpace = "pre-wrap";
      textBlock.style.wordBreak = "break-word";
      textBlock.style.display = "block";
    });
    if (this.previousAttempts.length > 0) {
      const attemptsDiv = contentEl.createDiv("previous-attempts");
      attemptsDiv.createEl("p", {
        text: `Previous attempts with speaker counts: ${this.previousAttempts.join(", ")}`
      });
    }
    const buttonContainer = contentEl.createDiv("button-container");
    new import_obsidian2.Setting(buttonContainer).addButton((button) => button.setButtonText("Accept Speaker Detection").setCta().onClick(() => {
      this.showSpeakerIdentification();
    }));
    new import_obsidian2.Setting(buttonContainer).addButton((button) => button.setButtonText("Incorrect Number of Speakers").onClick(() => {
      this.showSpeakerCountPrompt();
    }));
    contentEl.createEl("p", {
      text: "Note: Pressing escape or clicking outside will accept the current speaker detection.",
      cls: "speaker-review-note"
    });
  }
  showSpeakerIdentification() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Identify Speakers" });
    contentEl.createEl("p", { text: "Please identify each speaker using the options below." });
    const identificationContainer = contentEl.createDiv("speaker-identification");
    const speakerIdentifications = [];
    this.speakerSamples.forEach((sample) => {
      const speakerSection = identificationContainer.createDiv("speaker-section");
      const sampleDiv = speakerSection.createDiv("speaker-sample");
      const speakerLabel = sampleDiv.createSpan("speaker-label");
      speakerLabel.createEl("strong", { text: sample.speaker });
      const textBlock = sampleDiv.createSpan("speaker-text");
      textBlock.setText(sample.text);
      sampleDiv.style.display = "flex";
      sampleDiv.style.gap = "1em";
      sampleDiv.style.marginBottom = "0.5em";
      speakerLabel.style.minWidth = "120px";
      speakerLabel.style.flexShrink = "0";
      textBlock.style.flex = "1";
      textBlock.style.paddingLeft = "1em";
      textBlock.style.borderLeft = "1px solid var(--background-modifier-border)";
      textBlock.style.whiteSpace = "pre-wrap";
      textBlock.style.wordBreak = "break-word";
      textBlock.style.display = "block";
      const controlsDiv = speakerSection.createDiv("speaker-controls");
      controlsDiv.style.display = "flex";
      controlsDiv.style.gap = "1em";
      controlsDiv.style.marginLeft = "calc(120px + 2em)";
      controlsDiv.style.marginBottom = "1.5em";
      const identification = {
        speaker: sample.speaker
      };
      speakerIdentifications.push(identification);
      const inputContainer = controlsDiv.createDiv("input-container");
      inputContainer.style.display = "flex";
      inputContainer.style.gap = "1em";
      inputContainer.style.flex = "1";
      const textInput = inputContainer.createEl("input", {
        type: "text",
        placeholder: "Enter speaker name"
      });
      textInput.style.flex = "1";
      if (this.attendees.length > 0) {
        const dropdown = inputContainer.createEl("select");
        dropdown.style.minWidth = "150px";
        inputContainer.insertBefore(dropdown, textInput);
        dropdown.createEl("option", {
          text: "Select attendee",
          value: ""
        });
        this.attendees.forEach((attendee) => {
          dropdown.createEl("option", {
            text: attendee,
            value: attendee
          });
        });
        dropdown.addEventListener("change", () => {
          identification.selectedAttendee = dropdown.value;
          textInput.placeholder = dropdown.value ? "Enter alias (optional)" : "Enter speaker name";
          if (dropdown.value) {
            identification.name = void 0;
            identification.alias = textInput.value || void 0;
          } else {
            identification.name = textInput.value || void 0;
            identification.alias = void 0;
          }
        });
        textInput.addEventListener("input", () => {
          if (dropdown.value) {
            identification.alias = textInput.value || void 0;
          } else {
            identification.name = textInput.value || void 0;
          }
        });
      } else {
        textInput.addEventListener("input", () => {
          identification.name = textInput.value || void 0;
        });
      }
    });
    const buttonContainer = contentEl.createDiv("button-container");
    new import_obsidian2.Setting(buttonContainer).addButton((button) => button.setButtonText("Submit Identifications").setCta().onClick(async () => {
      const unidentified = speakerIdentifications.filter(
        (id) => !id.name && !id.selectedAttendee
      );
      if (unidentified.length > 0) {
        const confirm = await new Promise((resolve) => {
          const modal = new import_obsidian2.Modal(this.app);
          modal.titleEl.setText("Confirm Submission");
          modal.contentEl.createEl("p", {
            text: `${unidentified.length} speaker(s) are not identified. Do you want to continue?`
          });
          modal.scope.register([], "Enter", () => {
            resolve(true);
            modal.close();
            return false;
          });
          new import_obsidian2.Setting(modal.contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => {
            resolve(false);
            modal.close();
          })).addButton((btn) => btn.setButtonText("Continue").setCta().onClick(() => {
            resolve(true);
            modal.close();
          }));
          modal.open();
        });
        if (!confirm)
          return;
      }
      this.onSubmit({
        accepted: true,
        speakerIdentifications
      });
      this.close();
    }));
    const textInputs = contentEl.querySelectorAll('input[type="text"]');
    textInputs.forEach((input, index) => {
      input.addEventListener("keydown", (evt) => {
        if (evt.key === "Enter") {
          evt.preventDefault();
          if (index === textInputs.length - 1) {
            const submitButton = contentEl.querySelector(".mod-cta");
            if (submitButton instanceof HTMLButtonElement) {
              submitButton.click();
            }
          } else {
            const nextInput = textInputs[index + 1];
            if (nextInput) {
              nextInput.focus();
            }
          }
        }
      });
    });
  }
  showSpeakerCountPrompt() {
    const promptDiv = document.createElement("div");
    promptDiv.addClass("speaker-count-prompt");
    const modal = new import_obsidian2.Modal(this.app);
    modal.titleEl.setText("Enter Speaker Count");
    const { contentEl } = modal;
    let speakerCount;
    modal.scope.register([], "Enter", (evt) => {
      const activeElement = document.activeElement;
      if (activeElement instanceof HTMLInputElement) {
        return false;
      }
      const ctaButton = contentEl.querySelector(".mod-cta");
      if (ctaButton instanceof HTMLButtonElement) {
        ctaButton.click();
      }
      return false;
    });
    new import_obsidian2.Setting(contentEl).setName("Number of Speakers").setDesc("Enter the correct number of speakers in the audio").addText((text) => text.setPlaceholder("e.g., 2").onChange((value) => {
      speakerCount = value ? parseInt(value) : void 0;
    }));
    new import_obsidian2.Setting(contentEl).addButton((button) => button.setButtonText("Cancel").onClick(() => {
      modal.close();
    })).addButton((button) => button.setButtonText("Submit").setCta().onClick(() => {
      if (!speakerCount || speakerCount < 1) {
        new import_obsidian2.Notice("Please enter a valid number of speakers");
        return;
      }
      this.onSubmit({
        accepted: false,
        speakerCount
      });
      modal.close();
      this.close();
    }));
    modal.open();
    const numberInput = contentEl.querySelector('input[type="text"]');
    if (numberInput) {
      numberInput.addEventListener("keydown", (evt) => {
        if (evt.key === "Enter") {
          evt.preventDefault();
          const submitButton = contentEl.querySelector(".mod-cta");
          if (submitButton instanceof HTMLButtonElement) {
            submitButton.click();
          }
        }
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.onSubmit({ accepted: true });
  }
};

// node_modules/assemblyai/dist/browser.mjs
var DEFAULT_FETCH_INIT = {
  cache: "no-store"
};
var buildUserAgent = (userAgent) => defaultUserAgentString + (userAgent === false ? "" : " AssemblyAI/1.0 (" + Object.entries({ ...defaultUserAgent, ...userAgent }).map(([key, item]) => item ? `${key}=${item.name}/${item.version}` : "").join(" ") + ")");
var defaultUserAgentString = "";
if (typeof navigator !== "undefined" && navigator.userAgent) {
  defaultUserAgentString += navigator.userAgent;
}
var defaultUserAgent = {
  sdk: { name: "JavaScript", version: "4.8.0" }
};
if (typeof process !== "undefined") {
  if (process.versions.node && defaultUserAgentString.indexOf("Node") === -1) {
    defaultUserAgent.runtime_env = {
      name: "Node",
      version: process.versions.node
    };
  }
  if (process.versions.bun && defaultUserAgentString.indexOf("Bun") === -1) {
    defaultUserAgent.runtime_env = {
      name: "Bun",
      version: process.versions.bun
    };
  }
}
if (typeof Deno !== "undefined") {
  if (process.versions.bun && defaultUserAgentString.indexOf("Deno") === -1) {
    defaultUserAgent.runtime_env = { name: "Deno", version: Deno.version.deno };
  }
}
var BaseService = class {
  /**
   * Create a new service.
   * @param params - The parameters to use for the service.
   */
  constructor(params) {
    this.params = params;
    if (params.userAgent === false) {
      this.userAgent = void 0;
    } else {
      this.userAgent = buildUserAgent(params.userAgent || {});
    }
  }
  async fetch(input, init) {
    init = { ...DEFAULT_FETCH_INIT, ...init };
    let headers = {
      Authorization: this.params.apiKey,
      "Content-Type": "application/json"
    };
    if (DEFAULT_FETCH_INIT == null ? void 0 : DEFAULT_FETCH_INIT.headers)
      headers = { ...headers, ...DEFAULT_FETCH_INIT.headers };
    if (init == null ? void 0 : init.headers)
      headers = { ...headers, ...init.headers };
    if (this.userAgent) {
      headers["User-Agent"] = this.userAgent;
      {
        if (typeof window !== "undefined" && "chrome" in window) {
          headers["AssemblyAI-Agent"] = this.userAgent;
        }
      }
    }
    init.headers = headers;
    if (!input.startsWith("http"))
      input = this.params.baseUrl + input;
    const response = await fetch(input, init);
    if (response.status >= 400) {
      let json;
      const text = await response.text();
      if (text) {
        try {
          json = JSON.parse(text);
        } catch (e) {
        }
        if (json == null ? void 0 : json.error)
          throw new Error(json.error);
        throw new Error(text);
      }
      throw new Error(`HTTP Error: ${response.status} ${response.statusText}`);
    }
    return response;
  }
  async fetchJson(input, init) {
    const response = await this.fetch(input, init);
    return response.json();
  }
};
var LemurService = class extends BaseService {
  summary(params) {
    return this.fetchJson("/lemur/v3/generate/summary", {
      method: "POST",
      body: JSON.stringify(params)
    });
  }
  questionAnswer(params) {
    return this.fetchJson("/lemur/v3/generate/question-answer", {
      method: "POST",
      body: JSON.stringify(params)
    });
  }
  actionItems(params) {
    return this.fetchJson("/lemur/v3/generate/action-items", {
      method: "POST",
      body: JSON.stringify(params)
    });
  }
  task(params) {
    return this.fetchJson("/lemur/v3/generate/task", {
      method: "POST",
      body: JSON.stringify(params)
    });
  }
  getResponse(id) {
    return this.fetchJson(`/lemur/v3/${id}`);
  }
  /**
   * Delete the data for a previously submitted LeMUR request.
   * @param id - ID of the LeMUR request
   */
  purgeRequestData(id) {
    return this.fetchJson(`/lemur/v3/${id}`, {
      method: "DELETE"
    });
  }
};
var { WritableStream } = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : globalThis;
var _a, _b;
var PolyfillWebSocket = (_b = (_a = WebSocket != null ? WebSocket : global == null ? void 0 : global.WebSocket) != null ? _a : window == null ? void 0 : window.WebSocket) != null ? _b : self == null ? void 0 : self.WebSocket;
var factory = (url, params) => {
  if (params) {
    return new PolyfillWebSocket(url, params);
  }
  return new PolyfillWebSocket(url);
};
var RealtimeErrorType = {
  BadSampleRate: 4e3,
  AuthFailed: 4001,
  /**
   * @deprecated Use InsufficientFunds or FreeTierUser instead
   */
  InsufficientFundsOrFreeAccount: 4002,
  InsufficientFunds: 4002,
  FreeTierUser: 4003,
  NonexistentSessionId: 4004,
  SessionExpired: 4008,
  ClosedSession: 4010,
  RateLimited: 4029,
  UniqueSessionViolation: 4030,
  SessionTimeout: 4031,
  AudioTooShort: 4032,
  AudioTooLong: 4033,
  AudioTooSmallToTranscode: 4034,
  /**
   * @deprecated Don't use
   */
  BadJson: 4100,
  BadSchema: 4101,
  TooManyStreams: 4102,
  Reconnected: 4103,
  /**
   * @deprecated Don't use
   */
  ReconnectAttemptsExhausted: 1013,
  WordBoostParameterParsingFailed: 4104
};
var RealtimeErrorMessages = {
  [RealtimeErrorType.BadSampleRate]: "Sample rate must be a positive integer",
  [RealtimeErrorType.AuthFailed]: "Not Authorized",
  [RealtimeErrorType.InsufficientFunds]: "Insufficient funds",
  [RealtimeErrorType.FreeTierUser]: "This feature is paid-only and requires you to add a credit card. Please visit https://app.assemblyai.com/ to add a credit card to your account.",
  [RealtimeErrorType.NonexistentSessionId]: "Session ID does not exist",
  [RealtimeErrorType.SessionExpired]: "Session has expired",
  [RealtimeErrorType.ClosedSession]: "Session is closed",
  [RealtimeErrorType.RateLimited]: "Rate limited",
  [RealtimeErrorType.UniqueSessionViolation]: "Unique session violation",
  [RealtimeErrorType.SessionTimeout]: "Session Timeout",
  [RealtimeErrorType.AudioTooShort]: "Audio too short",
  [RealtimeErrorType.AudioTooLong]: "Audio too long",
  [RealtimeErrorType.AudioTooSmallToTranscode]: "Audio too small to transcode",
  [RealtimeErrorType.BadJson]: "Bad JSON",
  [RealtimeErrorType.BadSchema]: "Bad schema",
  [RealtimeErrorType.TooManyStreams]: "Too many streams",
  [RealtimeErrorType.Reconnected]: "This session has been reconnected. This WebSocket is no longer valid.",
  [RealtimeErrorType.ReconnectAttemptsExhausted]: "Reconnect attempts exhausted",
  [RealtimeErrorType.WordBoostParameterParsingFailed]: "Could not parse word boost parameter"
};
var RealtimeError = class extends Error {
};
var defaultRealtimeUrl = "wss://api.assemblyai.com/v2/realtime/ws";
var forceEndOfUtteranceMessage = `{"force_end_utterance":true}`;
var terminateSessionMessage = `{"terminate_session":true}`;
var RealtimeTranscriber = class {
  /**
   * Create a new RealtimeTranscriber.
   * @param params - Parameters to configure the RealtimeTranscriber
   */
  constructor(params) {
    var _a2, _b2;
    this.listeners = {};
    this.realtimeUrl = (_a2 = params.realtimeUrl) != null ? _a2 : defaultRealtimeUrl;
    this.sampleRate = (_b2 = params.sampleRate) != null ? _b2 : 16e3;
    this.wordBoost = params.wordBoost;
    this.encoding = params.encoding;
    this.endUtteranceSilenceThreshold = params.endUtteranceSilenceThreshold;
    this.disablePartialTranscripts = params.disablePartialTranscripts;
    if ("token" in params && params.token)
      this.token = params.token;
    if ("apiKey" in params && params.apiKey)
      this.apiKey = params.apiKey;
    if (!(this.token || this.apiKey)) {
      throw new Error("API key or temporary token is required.");
    }
  }
  connectionUrl() {
    const url = new URL(this.realtimeUrl);
    if (url.protocol !== "wss:") {
      throw new Error("Invalid protocol, must be wss");
    }
    const searchParams = new URLSearchParams();
    if (this.token) {
      searchParams.set("token", this.token);
    }
    searchParams.set("sample_rate", this.sampleRate.toString());
    if (this.wordBoost && this.wordBoost.length > 0) {
      searchParams.set("word_boost", JSON.stringify(this.wordBoost));
    }
    if (this.encoding) {
      searchParams.set("encoding", this.encoding);
    }
    searchParams.set("enable_extra_session_information", "true");
    if (this.disablePartialTranscripts) {
      searchParams.set("disable_partial_transcripts", this.disablePartialTranscripts.toString());
    }
    url.search = searchParams.toString();
    return url;
  }
  /**
   * Add a listener for an event.
   * @param event - The event to listen for.
   * @param listener - The function to call when the event is emitted.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  on(event, listener) {
    this.listeners[event] = listener;
  }
  /**
   * Connect to the server and begin a new session.
   * @returns A promise that resolves when the connection is established and the session begins.
   */
  connect() {
    return new Promise((resolve) => {
      if (this.socket) {
        throw new Error("Already connected");
      }
      const url = this.connectionUrl();
      if (this.token) {
        this.socket = factory(url.toString());
      } else {
        {
          console.warn(`API key authentication is not supported for the RealtimeTranscriber in browser environment. Use temporary token authentication instead.
Learn more at https://github.com/AssemblyAI/assemblyai-node-sdk/blob/main/docs/compat.md#browser-compatibility.`);
        }
        this.socket = factory(url.toString(), {
          headers: { Authorization: this.apiKey }
        });
      }
      this.socket.binaryType = "arraybuffer";
      this.socket.onopen = () => {
        if (this.endUtteranceSilenceThreshold === void 0 || this.endUtteranceSilenceThreshold === null) {
          return;
        }
        this.configureEndUtteranceSilenceThreshold(this.endUtteranceSilenceThreshold);
      };
      this.socket.onclose = ({ code, reason }) => {
        var _a2, _b2;
        if (!reason) {
          if (code in RealtimeErrorMessages) {
            reason = RealtimeErrorMessages[code];
          }
        }
        (_b2 = (_a2 = this.listeners).close) == null ? void 0 : _b2.call(_a2, code, reason);
      };
      this.socket.onerror = (event) => {
        var _a2, _b2, _c, _d;
        if (event.error)
          (_b2 = (_a2 = this.listeners).error) == null ? void 0 : _b2.call(_a2, event.error);
        else
          (_d = (_c = this.listeners).error) == null ? void 0 : _d.call(_c, new Error(event.message));
      };
      this.socket.onmessage = ({ data }) => {
        var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
        const message = JSON.parse(data.toString());
        if ("error" in message) {
          (_b2 = (_a2 = this.listeners).error) == null ? void 0 : _b2.call(_a2, new RealtimeError(message.error));
          return;
        }
        switch (message.message_type) {
          case "SessionBegins": {
            const openObject = {
              sessionId: message.session_id,
              expiresAt: new Date(message.expires_at)
            };
            resolve(openObject);
            (_d = (_c = this.listeners).open) == null ? void 0 : _d.call(_c, openObject);
            break;
          }
          case "PartialTranscript": {
            message.created = new Date(message.created);
            (_f = (_e = this.listeners).transcript) == null ? void 0 : _f.call(_e, message);
            (_h = (_g = this.listeners)["transcript.partial"]) == null ? void 0 : _h.call(_g, message);
            break;
          }
          case "FinalTranscript": {
            message.created = new Date(message.created);
            (_j = (_i = this.listeners).transcript) == null ? void 0 : _j.call(_i, message);
            (_l = (_k = this.listeners)["transcript.final"]) == null ? void 0 : _l.call(_k, message);
            break;
          }
          case "SessionInformation": {
            (_n = (_m = this.listeners).session_information) == null ? void 0 : _n.call(_m, message);
            break;
          }
          case "SessionTerminated": {
            (_o = this.sessionTerminatedResolve) == null ? void 0 : _o.call(this);
            break;
          }
        }
      };
    });
  }
  /**
   * Send audio data to the server.
   * @param audio - The audio data to send to the server.
   */
  sendAudio(audio) {
    this.send(audio);
  }
  /**
   * Create a writable stream that can be used to send audio data to the server.
   * @returns A writable stream that can be used to send audio data to the server.
   */
  stream() {
    return new WritableStream({
      write: (chunk) => {
        this.sendAudio(chunk);
      }
    });
  }
  /**
   * Manually end an utterance
   */
  forceEndUtterance() {
    this.send(forceEndOfUtteranceMessage);
  }
  /**
   * Configure the threshold for how long to wait before ending an utterance. Default is 700ms.
   * @param threshold - The duration of the end utterance silence threshold in milliseconds.
   * This value must be an integer between 0 and 20_000.
   */
  configureEndUtteranceSilenceThreshold(threshold) {
    this.send(`{"end_utterance_silence_threshold":${threshold}}`);
  }
  send(data) {
    if (!this.socket || this.socket.readyState !== this.socket.OPEN) {
      throw new Error("Socket is not open for communication");
    }
    this.socket.send(data);
  }
  /**
   * Close the connection to the server.
   * @param waitForSessionTermination - If true, the method will wait for the session to be terminated before closing the connection.
   * While waiting for the session to be terminated, you will receive the final transcript and session information.
   */
  async close(waitForSessionTermination = true) {
    var _a2;
    if (this.socket) {
      if (this.socket.readyState === this.socket.OPEN) {
        if (waitForSessionTermination) {
          const sessionTerminatedPromise = new Promise((resolve) => {
            this.sessionTerminatedResolve = resolve;
          });
          this.socket.send(terminateSessionMessage);
          await sessionTerminatedPromise;
        } else {
          this.socket.send(terminateSessionMessage);
        }
      }
      if ((_a2 = this.socket) == null ? void 0 : _a2.removeAllListeners)
        this.socket.removeAllListeners();
      this.socket.close();
    }
    this.listeners = {};
    this.socket = void 0;
  }
};
var RealtimeTranscriberFactory = class extends BaseService {
  constructor(params) {
    super(params);
    this.rtFactoryParams = params;
  }
  /**
   * @deprecated Use transcriber(...) instead
   */
  createService(params) {
    return this.transcriber(params);
  }
  transcriber(params) {
    const serviceParams = { ...params };
    if (!serviceParams.token && !serviceParams.apiKey) {
      serviceParams.apiKey = this.rtFactoryParams.apiKey;
    }
    return new RealtimeTranscriber(serviceParams);
  }
  async createTemporaryToken(params) {
    const data = await this.fetchJson("/v2/realtime/token", {
      method: "POST",
      body: JSON.stringify(params)
    });
    return data.token;
  }
};
function getPath(path) {
  if (path.startsWith("http"))
    return null;
  if (path.startsWith("https"))
    return null;
  if (path.startsWith("data:"))
    return null;
  if (path.startsWith("file://"))
    return path.substring(7);
  if (path.startsWith("file:"))
    return path.substring(5);
  return path;
}
var TranscriptService = class extends BaseService {
  constructor(params, files) {
    super(params);
    this.files = files;
  }
  /**
   * Transcribe an audio file. This will create a transcript and wait until the transcript status is "completed" or "error".
   * @param params - The parameters to transcribe an audio file.
   * @param options - The options to transcribe an audio file.
   * @returns A promise that resolves to the transcript. The transcript status is "completed" or "error".
   */
  async transcribe(params, options) {
    const transcript = await this.submit(params);
    return await this.waitUntilReady(transcript.id, options);
  }
  /**
   * Submits a transcription job for an audio file. This will not wait until the transcript status is "completed" or "error".
   * @param params - The parameters to start the transcription of an audio file.
   * @returns A promise that resolves to the queued transcript.
   */
  async submit(params) {
    let audioUrl;
    let transcriptParams = void 0;
    if ("audio" in params) {
      const { audio, ...audioTranscriptParams } = params;
      if (typeof audio === "string") {
        const path = getPath(audio);
        if (path !== null) {
          audioUrl = await this.files.upload(path);
        } else {
          if (audio.startsWith("data:")) {
            audioUrl = await this.files.upload(audio);
          } else {
            audioUrl = audio;
          }
        }
      } else {
        audioUrl = await this.files.upload(audio);
      }
      transcriptParams = { ...audioTranscriptParams, audio_url: audioUrl };
    } else {
      transcriptParams = params;
    }
    const data = await this.fetchJson("/v2/transcript", {
      method: "POST",
      body: JSON.stringify(transcriptParams)
    });
    return data;
  }
  /**
   * Create a transcript.
   * @param params - The parameters to create a transcript.
   * @param options - The options used for creating the new transcript.
   * @returns A promise that resolves to the transcript.
   * @deprecated Use `transcribe` instead to transcribe a audio file that includes polling, or `submit` to transcribe a audio file without polling.
   */
  async create(params, options) {
    var _a2;
    const path = getPath(params.audio_url);
    if (path !== null) {
      const uploadUrl = await this.files.upload(path);
      params.audio_url = uploadUrl;
    }
    const data = await this.fetchJson("/v2/transcript", {
      method: "POST",
      body: JSON.stringify(params)
    });
    if ((_a2 = options == null ? void 0 : options.poll) != null ? _a2 : true) {
      return await this.waitUntilReady(data.id, options);
    }
    return data;
  }
  /**
   * Wait until the transcript ready, either the status is "completed" or "error".
   * @param transcriptId - The ID of the transcript.
   * @param options - The options to wait until the transcript is ready.
   * @returns A promise that resolves to the transcript. The transcript status is "completed" or "error".
   */
  async waitUntilReady(transcriptId, options) {
    var _a2, _b2;
    const pollingInterval = (_a2 = options == null ? void 0 : options.pollingInterval) != null ? _a2 : 3e3;
    const pollingTimeout = (_b2 = options == null ? void 0 : options.pollingTimeout) != null ? _b2 : -1;
    const startTime = Date.now();
    while (true) {
      const transcript = await this.get(transcriptId);
      if (transcript.status === "completed" || transcript.status === "error") {
        return transcript;
      } else if (pollingTimeout > 0 && Date.now() - startTime > pollingTimeout) {
        throw new Error("Polling timeout");
      } else {
        await new Promise((resolve) => setTimeout(resolve, pollingInterval));
      }
    }
  }
  /**
   * Retrieve a transcript.
   * @param id - The identifier of the transcript.
   * @returns A promise that resolves to the transcript.
   */
  get(id) {
    return this.fetchJson(`/v2/transcript/${id}`);
  }
  /**
   * Retrieves a page of transcript listings.
   * @param params - The parameters to filter the transcript list by, or the URL to retrieve the transcript list from.
   */
  async list(params) {
    let url = "/v2/transcript";
    if (typeof params === "string") {
      url = params;
    } else if (params) {
      url = `${url}?${new URLSearchParams(Object.keys(params).map((key) => {
        var _a2;
        return [
          key,
          ((_a2 = params[key]) == null ? void 0 : _a2.toString()) || ""
        ];
      }))}`;
    }
    const data = await this.fetchJson(url);
    for (const transcriptListItem of data.transcripts) {
      transcriptListItem.created = new Date(transcriptListItem.created);
      if (transcriptListItem.completed) {
        transcriptListItem.completed = new Date(transcriptListItem.completed);
      }
    }
    return data;
  }
  /**
   * Delete a transcript
   * @param id - The identifier of the transcript.
   * @returns A promise that resolves to the transcript.
   */
  delete(id) {
    return this.fetchJson(`/v2/transcript/${id}`, { method: "DELETE" });
  }
  /**
   * Search through the transcript for a specific set of keywords.
   * You can search for individual words, numbers, or phrases containing up to five words or numbers.
   * @param id - The identifier of the transcript.
   * @param words - Keywords to search for.
   * @returns A promise that resolves to the sentences.
   */
  wordSearch(id, words) {
    const params = new URLSearchParams({ words: words.join(",") });
    return this.fetchJson(`/v2/transcript/${id}/word-search?${params.toString()}`);
  }
  /**
   * Retrieve all sentences of a transcript.
   * @param id - The identifier of the transcript.
   * @returns A promise that resolves to the sentences.
   */
  sentences(id) {
    return this.fetchJson(`/v2/transcript/${id}/sentences`);
  }
  /**
   * Retrieve all paragraphs of a transcript.
   * @param id - The identifier of the transcript.
   * @returns A promise that resolves to the paragraphs.
   */
  paragraphs(id) {
    return this.fetchJson(`/v2/transcript/${id}/paragraphs`);
  }
  /**
   * Retrieve subtitles of a transcript.
   * @param id - The identifier of the transcript.
   * @param format - The format of the subtitles.
   * @param chars_per_caption - The maximum number of characters per caption.
   * @returns A promise that resolves to the subtitles text.
   */
  async subtitles(id, format = "srt", chars_per_caption) {
    let url = `/v2/transcript/${id}/${format}`;
    if (chars_per_caption) {
      const params = new URLSearchParams();
      params.set("chars_per_caption", chars_per_caption.toString());
      url += `?${params.toString()}`;
    }
    const response = await this.fetch(url);
    return await response.text();
  }
  /**
   * Retrieve the redacted audio URL of a transcript.
   * @param id - The identifier of the transcript.
   * @returns A promise that resolves to the details of the redacted audio.
   * @deprecated Use `redactedAudio` instead.
   */
  redactions(id) {
    return this.redactedAudio(id);
  }
  /**
   * Retrieve the redacted audio URL of a transcript.
   * @param id - The identifier of the transcript.
   * @returns A promise that resolves to the details of the redacted audio.
   */
  redactedAudio(id) {
    return this.fetchJson(`/v2/transcript/${id}/redacted-audio`);
  }
  /**
   * Retrieve the redacted audio file of a transcript.
   * @param id - The identifier of the transcript.
   * @returns A promise that resolves to the fetch HTTP response of the redacted audio file.
   */
  async redactedAudioFile(id) {
    const { redacted_audio_url, status } = await this.redactedAudio(id);
    if (status !== "redacted_audio_ready") {
      throw new Error(`Redacted audio status is ${status}`);
    }
    const response = await fetch(redacted_audio_url);
    if (!response.ok) {
      throw new Error(`Failed to fetch redacted audio: ${response.statusText}`);
    }
    return {
      arrayBuffer: response.arrayBuffer.bind(response),
      blob: response.blob.bind(response),
      body: response.body,
      bodyUsed: response.bodyUsed
    };
  }
};
var readFile = async function(path) {
  throw new Error("Interacting with the file system is not supported in this environment.");
};
var FileService = class extends BaseService {
  /**
   * Upload a local file to AssemblyAI.
   * @param input - The local file path to upload, or a stream or buffer of the file to upload.
   * @returns A promise that resolves to the uploaded file URL.
   */
  async upload(input) {
    let fileData;
    if (typeof input === "string") {
      if (input.startsWith("data:")) {
        fileData = dataUrlToBlob(input);
      } else {
        fileData = await readFile();
      }
    } else
      fileData = input;
    const data = await this.fetchJson("/v2/upload", {
      method: "POST",
      body: fileData,
      headers: {
        "Content-Type": "application/octet-stream"
      },
      duplex: "half"
    });
    return data.upload_url;
  }
};
function dataUrlToBlob(dataUrl) {
  const arr = dataUrl.split(",");
  const mime = arr[0].match(/:(.*?);/)[1];
  const bstr = atob(arr[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new Blob([u8arr], { type: mime });
}
var defaultBaseUrl = "https://api.assemblyai.com";
var AssemblyAI = class {
  /**
   * Create a new AssemblyAI client.
   * @param params - The parameters for the service, including the API key and base URL, if any.
   */
  constructor(params) {
    params.baseUrl = params.baseUrl || defaultBaseUrl;
    if (params.baseUrl && params.baseUrl.endsWith("/")) {
      params.baseUrl = params.baseUrl.slice(0, -1);
    }
    this.files = new FileService(params);
    this.transcripts = new TranscriptService(params, this.files);
    this.lemur = new LemurService(params);
    this.realtime = new RealtimeTranscriberFactory(params);
  }
};

// src/AudioHandler.ts
var import_obsidian4 = require("obsidian");
var https = __toESM(require("https"));
var AudioHandler = class {
  constructor(plugin) {
    this.assemblyClient = null;
    this.plugin = plugin;
  }
  initializeAssemblyAI() {
    if (this.plugin.settings.assemblyAiApiKey) {
      try {
        this.assemblyClient = new AssemblyAI({
          apiKey: this.plugin.settings.assemblyAiApiKey
        });
        if (this.plugin.settings.debugMode) {
          console.log("AssemblyAI client initialized");
        }
      } catch (error) {
        console.error("Failed to initialize AssemblyAI client:", error);
        new import_obsidian3.Notice("Failed to initialize AssemblyAI client");
      }
    }
  }
  /**
   * Processes audio using either Whisper or AssemblyAI based on settings
   */
  async processAudioChunks(blob, fileName) {
    try {
      if (this.plugin.settings.transcriptionService === "assemblyai") {
        const speakerCount = await this.promptForSpeakerCount();
        this.initializeAssemblyAI();
        await this.processWithAssemblyAI(blob, speakerCount);
      } else {
        await this.processWithWhisper(blob, fileName);
      }
    } catch (error) {
      if (this.plugin.statusBar) {
        this.plugin.statusBar.updateStatus("idle" /* Idle */);
      }
      throw error;
    }
  }
  async promptForSpeakerCount() {
    return new Promise((resolve) => {
      const modal = new import_obsidian4.Modal(this.plugin.app);
      modal.titleEl.setText("Speaker Count");
      const contentEl = modal.contentEl;
      contentEl.createEl("p", {
        text: "If you know how many speakers are in this recording, enter the number below. This can help improve speaker detection accuracy. Leave empty if unsure."
      });
      let speakerCount;
      new import_obsidian4.Setting(contentEl).setName("Number of Speakers").setDesc("Optional: Enter the number of speakers").addText((text) => text.setPlaceholder("e.g., 2").onChange((value) => {
        speakerCount = value ? parseInt(value) : void 0;
      }));
      new import_obsidian4.Setting(contentEl).addButton((button) => button.setButtonText("Cancel").onClick(() => {
        modal.close();
        resolve(void 0);
      })).addButton((button) => button.setButtonText("Continue").setCta().onClick(() => {
        modal.close();
        resolve(speakerCount);
      }));
      modal.open();
    });
  }
  async promptForDeletionCount() {
    return new Promise((resolve) => {
      const modal = new import_obsidian4.Modal(this.plugin.app);
      modal.titleEl.setText("Delete Transcripts");
      const contentEl = modal.contentEl;
      contentEl.createEl("p", {
        text: "How many recent transcripts would you like to delete?"
      });
      let transcriptCount;
      let deleteAll = false;
      new import_obsidian4.Setting(contentEl).setName("Number of Transcripts").setDesc("Enter the number of most recent transcripts to delete").addText((text) => {
        text.setPlaceholder("e.g., 10").setValue("").setDisabled(false).onChange((value) => {
          transcriptCount = value ? parseInt(value) : void 0;
        });
        return text;
      });
      new import_obsidian4.Setting(contentEl).setName("Delete All").setDesc("Delete all transcripts").addToggle((toggle) => {
        toggle.setValue(false).onChange((value) => {
          deleteAll = value;
          const textInput = contentEl.querySelector('input[type="text"]');
          if (textInput) {
            textInput.disabled = value;
            if (value) {
              textInput.value = "";
              transcriptCount = void 0;
            }
          }
        });
      });
      new import_obsidian4.Setting(contentEl).addButton((button) => button.setButtonText("Cancel").onClick(() => {
        modal.close();
        resolve({ count: void 0, deleteAll: false });
      })).addButton((button) => button.setButtonText("Delete").setCta().onClick(() => {
        modal.close();
        resolve({ count: transcriptCount, deleteAll });
      }));
      modal.open();
    });
  }
  /**
   * Delete a transcript from AssemblyAI
   * Note: We use Node.js https module directly instead of the AssemblyAI SDK because
   * the SDK's delete method uses browser's fetch API which triggers CORS preflight checks.
   * Since we're in Electron (Obsidian), using Node.js https module bypasses these CORS restrictions.
   */
  async deleteTranscript(transcriptId, reason) {
    try {
      if (this.plugin.settings.debugMode) {
        console.log(`Attempting to delete ${reason} transcript:`, transcriptId);
      }
      this.initializeAssemblyAI();
      if (!this.assemblyClient) {
        throw new Error("Failed to initialize AssemblyAI client for deletion");
      }
      const transcript = await this.assemblyClient.transcripts.get(transcriptId);
      if ((transcript == null ? void 0 : transcript.status) === "completed" || (transcript == null ? void 0 : transcript.status) === "error") {
        await new Promise((resolve, reject) => {
          const options = {
            hostname: "api.assemblyai.com",
            port: 443,
            path: `/v2/transcript/${transcriptId}`,
            method: "DELETE",
            headers: {
              "Authorization": this.plugin.settings.assemblyAiApiKey
            }
          };
          const req = https.request(options, (res) => {
            if (res.statusCode === 200 || res.statusCode === 204) {
              resolve();
            } else {
              reject(new Error(`Failed to delete transcript: ${res.statusCode}`));
            }
          });
          req.on("error", (error) => {
            reject(error);
          });
          req.end();
        });
        if (this.plugin.settings.debugMode) {
          console.log(`Deleted ${reason} transcript:`, transcriptId);
        }
      } else {
        console.log(`Skipping deletion of ${reason} transcript ${transcriptId} as status is: ${transcript == null ? void 0 : transcript.status}`);
      }
    } catch (deleteError) {
      console.error(`Error deleting ${reason} transcript:`, transcriptId, deleteError);
    }
  }
  /**
   * Process audio using AssemblyAI
   */
  async processWithAssemblyAI(audioData, initialSpeakerCount) {
    try {
      this.plugin.statusBar.updateStatus("processing" /* Processing */);
      if (!this.assemblyClient) {
        this.initializeAssemblyAI();
      }
      if (!this.assemblyClient) {
        throw new Error("Failed to initialize AssemblyAI client");
      }
      const previousAttempts = initialSpeakerCount ? [initialSpeakerCount] : [];
      let transcriptResult;
      let accepted = false;
      let speakerIdentifications;
      while (!accepted) {
        if (this.plugin.settings.debugMode) {
          console.log("Starting transcription attempt", {
            previousAttempts,
            currentAttempt: previousAttempts.length + 1
          });
        }
        const params = {
          audio: audioData,
          speaker_labels: true,
          speech_model: this.plugin.settings.assemblyAiModel || "best",
          boost_param: this.plugin.settings.boostParam
        };
        if (this.plugin.settings.prompt) {
          const wordBoostTerms = this.plugin.settings.prompt.split(",").map((term) => term.trim()).filter((term) => term.length > 0);
          if (this.plugin.settings.debugMode) {
            console.log("Word boost terms:", wordBoostTerms);
            console.log("Word boost terms (stringified):", JSON.stringify(wordBoostTerms));
          }
          params.word_boost = wordBoostTerms;
        }
        if (previousAttempts.length > 0) {
          params.speakers_expected = previousAttempts[previousAttempts.length - 1];
        }
        if (this.plugin.settings.debugMode) {
          console.log("Final params being sent to AssemblyAI:", JSON.stringify(params, null, 2));
        }
        transcriptResult = await this.assemblyClient.transcripts.transcribe(params);
        const currentTranscriptId = transcriptResult.id;
        if (this.plugin.settings.debugMode) {
          console.log("Received transcription result:", transcriptResult);
        }
        const speakerSamples = this.extractSpeakerSamples(transcriptResult);
        const activeFile = this.plugin.app.workspace.getActiveFile();
        const reviewResult = await new Promise((resolve) => {
          new SpeakerReviewModal(
            this.plugin.app,
            speakerSamples,
            previousAttempts,
            activeFile,
            resolve
          ).open();
        });
        if (this.plugin.settings.debugMode) {
          console.log("Speaker review result:", reviewResult);
        }
        if (reviewResult.accepted) {
          accepted = true;
          speakerIdentifications = reviewResult.speakerIdentifications;
          if (this.plugin.settings.debugMode) {
            console.log("Speaker detection accepted with identifications:", speakerIdentifications);
          }
          await this.deleteTranscript(currentTranscriptId, "accepted");
        } else if (reviewResult.speakerCount) {
          previousAttempts.push(reviewResult.speakerCount);
          if (this.plugin.settings.debugMode) {
            console.log("Retrying with new speaker count:", reviewResult.speakerCount);
          }
          await this.deleteTranscript(currentTranscriptId, "rejected");
        } else {
          accepted = true;
          if (this.plugin.settings.debugMode) {
            console.log("Modal closed without explicit decision, accepting current result");
          }
          await this.deleteTranscript(currentTranscriptId, "implicitly accepted");
        }
      }
      if (transcriptResult && speakerIdentifications) {
        transcriptResult.speakerIdentifications = speakerIdentifications;
      }
      if (transcriptResult) {
        await this.processTranscriptionResult(transcriptResult);
      }
    } catch (error) {
      console.error("Error in processWithAssemblyAI:", error);
      this.plugin.statusBar.updateStatus("idle" /* Idle */);
      new import_obsidian3.Notice(`Error processing audio: ${error.message}`);
    }
  }
  extractSpeakerSamples(transcript) {
    var _a2;
    const samples = [];
    const speakerUtterances = /* @__PURE__ */ new Map();
    (_a2 = transcript.utterances) == null ? void 0 : _a2.forEach((utterance) => {
      var _a3;
      if (!speakerUtterances.has(utterance.speaker)) {
        speakerUtterances.set(utterance.speaker, []);
      }
      (_a3 = speakerUtterances.get(utterance.speaker)) == null ? void 0 : _a3.push(utterance.text);
    });
    speakerUtterances.forEach((utterances, speaker) => {
      const text = this.getFirstTwoSentences(utterances.join(" "));
      samples.push({
        speaker: `Speaker ${speaker}:`,
        text
      });
    });
    if (this.plugin.settings.debugMode) {
      console.log("Extracted speaker samples:", samples);
    }
    return samples;
  }
  getFirstTwoSentences(text) {
    const sentences = text.match(/[^.!?]+[.!?]+/g) || [];
    return sentences.slice(0, 2).join(" ").trim();
  }
  async processTranscriptionResult(transcript) {
    if (this.plugin.settings.debugMode) {
      console.log("Processing accepted transcription result:", transcript);
    }
    try {
      let noteContent = "# Full Notes\n\n";
      let originalText = "";
      if (this.plugin.settings.useSpeakerDiarization && transcript.utterances) {
        if (this.plugin.settings.debugMode) {
          console.log("Processing speaker diarization with utterances:", transcript.utterances);
        }
        let currentSpeaker = "";
        for (const utterance of transcript.utterances) {
          if (utterance.speaker !== currentSpeaker) {
            originalText += `

**Speaker ${utterance.speaker}**: `;
            noteContent += `

- Speaker ${utterance.speaker}: `;
            currentSpeaker = utterance.speaker;
          }
          originalText += utterance.text + " ";
          noteContent += utterance.text + " ";
        }
        if (this.plugin.settings.usePostProcessing && transcript.speakerIdentifications) {
          if (this.plugin.settings.debugMode) {
            console.log("Starting post-processing for speaker mapping with identifications:", transcript.speakerIdentifications);
          }
          try {
            const speakerMappings = transcript.speakerIdentifications.map((id) => {
              if (id.alias) {
                return `${id.speaker} \u2192 ${id.alias}`;
              }
              const displayName = id.selectedAttendee || id.name || id.speaker;
              return `${id.speaker} \u2192 ${displayName}`;
            }).join("\n");
            const wordList = this.plugin.settings.prompt.split(",").map((term) => term.trim()).filter((term) => term.length > 0).join("\n- ");
            const mappingHeader = "Map all speakers to their actual names, based on the below mapping guide. However, ensure you also follow any instructions below.\n\nSpeaker Mappings:\n" + speakerMappings + "\n\nAdditionally, you should be on the lookout for words or phrases that may be any of the following, but misspelt. If you see any, please correct the spelling. Use your judgment and the context of the transcription to determine whether the transcription should have returned one of these words. However, ensure you also follow any instructions below (those should supercede this).\n\nWords/phrases to be on the lookout for:\n- " + wordList + "\n\n-------------------\nNOW, ONTO THE MAIN (AND MOST IMPORTANT) SET OF INSTRUCTIONS:\n-------------------\n\n";
            const customPrompt = this.plugin.settings.postProcessingPrompt || "Replace the speaker labels with their actual names while preserving the formatting.";
            const postProcessPrompt = mappingHeader + customPrompt;
            if (this.plugin.settings.debugMode) {
              console.log("Post-processing with prompt:", postProcessPrompt);
            }
            const isAnthropicModel = this.plugin.settings.postProcessingModel.startsWith("claude");
            let postProcessResponse;
            if (isAnthropicModel) {
              if (!this.plugin.settings.anthropicApiKey) {
                throw new Error("Anthropic API key is required for Claude models");
              }
              postProcessResponse = await axios_default.post(
                "https://api.anthropic.com/v1/messages",
                {
                  model: this.plugin.settings.postProcessingModel,
                  max_tokens: 8190,
                  messages: [
                    {
                      role: "user",
                      content: postProcessPrompt + "\n\n" + noteContent.replace("# Full Notes\n\n", "")
                    }
                  ]
                },
                {
                  headers: {
                    "Content-Type": "application/json",
                    "x-api-key": this.plugin.settings.anthropicApiKey,
                    "anthropic-version": "2023-06-01",
                    "anthropic-dangerous-direct-browser-access": "true"
                  }
                }
              );
              noteContent = "# Full Notes\n\n" + postProcessResponse.data.content[0].text;
            } else {
              postProcessResponse = await axios_default.post(
                "https://api.openai.com/v1/chat/completions",
                {
                  model: this.plugin.settings.postProcessingModel,
                  messages: [
                    {
                      role: "system",
                      content: postProcessPrompt
                    },
                    {
                      role: "user",
                      content: noteContent.replace("# Full Notes\n\n", "")
                    }
                  ],
                  temperature: 0.7
                },
                {
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${this.plugin.settings.openAiApiKey}`
                  }
                }
              );
              noteContent = "# Full Notes\n\n" + postProcessResponse.data.choices[0].message.content.trim();
            }
            if (this.plugin.settings.debugMode) {
              console.log("Post-processing complete");
            }
          } catch (postErr) {
            console.error("Error during post-processing:", postErr);
            new import_obsidian3.Notice("Error during post-processing: " + postErr.message);
          }
        }
      } else {
        originalText = transcript.text || "";
        const transcriptionText = transcript.text || "";
        noteContent += transcriptionText;
      }
      if (this.plugin.settings.keepOriginalTranscription && originalText !== noteContent) {
        noteContent += "\n\n# Raw Notes\n" + originalText;
      }
      const activeView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
      const shouldCreateNewFile = this.plugin.settings.createNewFileAfterRecording || !activeView;
      if (shouldCreateNewFile) {
        const now = /* @__PURE__ */ new Date();
        const fileName = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}-${String(now.getDate()).padStart(2, "0")}_${String(now.getHours()).padStart(2, "0")}-${String(now.getMinutes()).padStart(2, "0")}.md`;
        const filePath = `${this.plugin.settings.createNewFileAfterRecordingPath ? `${this.plugin.settings.createNewFileAfterRecordingPath}/` : ""}${fileName}`;
        await this.plugin.app.vault.create(filePath, noteContent);
        await this.plugin.app.workspace.openLinkText(filePath, "", true);
        new import_obsidian3.Notice(`Transcription saved to ${filePath}`);
      } else {
        const editor = activeView == null ? void 0 : activeView.editor;
        if (editor) {
          const cursorPosition = editor.getCursor();
          editor.replaceRange(noteContent, cursorPosition);
          const noteLines = noteContent.split("\n");
          const newPosition = {
            line: cursorPosition.line + noteLines.length - 1,
            ch: noteLines[noteLines.length - 1].length
          };
          editor.setCursor(newPosition);
          new import_obsidian3.Notice("Transcription inserted at cursor");
        }
      }
      this.plugin.statusBar.updateStatus("idle" /* Idle */);
    } catch (error) {
      console.error("Error processing transcription result:", error);
      this.plugin.statusBar.updateStatus("idle" /* Idle */);
      new import_obsidian3.Notice(`Error processing transcription: ${error.message}`);
      throw error;
    }
  }
  /**
   * Process audio using Whisper (existing chunked implementation)
   */
  async processWithWhisper(blob, fileName) {
    const chunkSize = 25 * 1024 * 1024;
    const numChunks = Math.ceil(blob.size / chunkSize);
    let completeTranscription = "";
    let completeOriginalText = "";
    let finalTitle = null;
    const baseFileName = getBaseFileName(fileName);
    let audioFilePath = `${this.plugin.settings.saveAudioFilePath ? `${this.plugin.settings.saveAudioFilePath}/` : ""}${fileName}`;
    let noteFilePath = `${this.plugin.settings.createNewFileAfterRecordingPath ? `${this.plugin.settings.createNewFileAfterRecordingPath}/` : ""}${baseFileName}.md`;
    if (this.plugin.settings.debugMode) {
      console.log("Base filename:", baseFileName);
      console.log("Audio file path:", audioFilePath);
      console.log("Note file path:", noteFilePath);
      console.log("Settings:", this.plugin.settings);
    }
    for (let i = 0; i < numChunks; i++) {
      const start = i * chunkSize;
      const end = Math.min(start + chunkSize, blob.size);
      const audioChunk = blob.slice(start, end);
      const chunkFileName = `${fileName}_chunk_${i}`;
      if (this.plugin.settings.debugMode) {
        console.log(`Processing chunk ${i + 1}/${numChunks}: ${chunkFileName}`);
      }
      try {
        if (this.plugin.settings.saveAudioFile) {
          try {
            const arrayBuffer = await audioChunk.arrayBuffer();
            await this.plugin.app.vault.adapter.writeBinary(
              audioFilePath,
              new Uint8Array(arrayBuffer)
            );
            new import_obsidian3.Notice("Audio chunk saved successfully.");
          } catch (err) {
            console.error("Error saving audio chunk:", err);
            new import_obsidian3.Notice("Error saving audio chunk: " + err.message);
          }
        }
        const { transcription, originalText } = await this.sendAudioData(audioChunk, chunkFileName);
        completeTranscription += transcription + "\n";
        completeOriginalText += originalText + "\n";
        if (i === 0 && this.plugin.settings.autoGenerateTitle && this.plugin.settings.titleGenerationPrompt) {
          finalTitle = await this.generateTitle(transcription);
          if (finalTitle) {
            const nowFileName = `${finalTitle} - ${fileName}`;
            const nowBaseFileName = getBaseFileName(nowFileName);
            const newAudioFilePath = `${this.plugin.settings.saveAudioFilePath ? `${this.plugin.settings.saveAudioFilePath}/` : ""}${nowFileName}`;
            if (this.plugin.settings.saveAudioFile) {
              await this.plugin.app.vault.adapter.rename(
                audioFilePath,
                newAudioFilePath
              );
            }
            audioFilePath = newAudioFilePath;
            noteFilePath = `${this.plugin.settings.createNewFileAfterRecordingPath ? `${this.plugin.settings.createNewFileAfterRecordingPath}/` : ""}${nowBaseFileName}.md`;
          }
        }
      } catch (err) {
        console.error(`Error processing chunk ${i + 1}/${numChunks}:`, err);
        new import_obsidian3.Notice(`Error processing chunk ${i + 1}: ${err.message}`);
      }
    }
    if (this.plugin.settings.debugMode) {
      console.log("Complete transcription length:", completeTranscription.length);
      console.log("Original text length:", completeOriginalText.length);
      console.log("Final title:", finalTitle);
    }
    let noteContent = "";
    if (finalTitle && finalTitle.trim() !== "") {
      noteContent = `# ${finalTitle}

`;
      if (this.plugin.settings.saveAudioFile) {
        noteContent += `![[${audioFilePath}]]

`;
      }
    } else if (this.plugin.settings.saveAudioFile) {
      noteContent = `![[${audioFilePath}]]

`;
    }
    noteContent += "# Full Notes\n\n" + completeTranscription;
    if (this.plugin.settings.keepOriginalTranscription && completeOriginalText !== completeTranscription) {
      noteContent += "\n\n# Raw Notes\n" + completeOriginalText;
    }
    const activeView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    const shouldCreateNewFile = this.plugin.settings.createNewFileAfterRecording || !activeView;
    try {
      if (shouldCreateNewFile) {
        if (this.plugin.settings.debugMode) {
          console.log("Creating new file:", noteFilePath);
          console.log("Content length:", noteContent.length);
        }
        if (!noteContent || noteContent.trim() === "") {
          throw new Error("No content to save");
        }
        await this.plugin.app.vault.create(noteFilePath, noteContent);
        await this.plugin.app.workspace.openLinkText(noteFilePath, "", true);
        new import_obsidian3.Notice(`Transcription saved to ${noteFilePath}`);
      } else {
        const editor = activeView == null ? void 0 : activeView.editor;
        if (editor) {
          const cursorPosition = editor.getCursor();
          editor.replaceRange(noteContent, cursorPosition);
          const noteLines = noteContent.split("\n");
          const newPosition = {
            line: cursorPosition.line + noteLines.length - 1,
            ch: noteLines[noteLines.length - 1].length
          };
          editor.setCursor(newPosition);
          new import_obsidian3.Notice("Transcription inserted at cursor");
        }
      }
    } catch (error) {
      console.error("Error in processAudioChunks:", error);
      new import_obsidian3.Notice(`Error processing audio: ${error.message}`);
      throw error;
    }
  }
  async generateTitle(text) {
    if (this.plugin.settings.debugMode) {
      new import_obsidian3.Notice("Generating title...");
    }
    try {
      let titleResponse;
      const isAnthropicModel = this.plugin.settings.postProcessingModel.startsWith("claude");
      if (isAnthropicModel) {
        if (!this.plugin.settings.anthropicApiKey) {
          throw new Error("Anthropic API key is required for Claude models");
        }
        titleResponse = await axios_default.post(
          "https://api.anthropic.com/v1/messages",
          {
            model: this.plugin.settings.postProcessingModel,
            max_tokens: 1e3,
            messages: [
              {
                role: "user",
                content: this.plugin.settings.titleGenerationPrompt + "\n\n" + text
              }
            ]
          },
          {
            headers: {
              "Content-Type": "application/json",
              "x-api-key": this.plugin.settings.anthropicApiKey,
              "anthropic-version": "2023-06-01",
              "anthropic-dangerous-direct-browser-access": "true"
            }
          }
        );
        return titleResponse.data.content[0].text.replace(/[/\\?%*:|"<>]/g, "-").replace(/\n/g, " ").trim();
      } else {
        titleResponse = await axios_default.post(
          "https://api.openai.com/v1/chat/completions",
          {
            model: this.plugin.settings.postProcessingModel || "gpt-4",
            messages: [
              {
                role: "system",
                content: this.plugin.settings.titleGenerationPrompt
              },
              {
                role: "user",
                content: text
              }
            ],
            temperature: 0.7
          },
          {
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${this.plugin.settings.openAiApiKey}`
            }
          }
        );
        return titleResponse.data.choices[0].message.content.trim().replace(/[/\\?%*:|"<>]/g, "-").replace(/\n/g, " ").trim();
      }
    } catch (titleErr) {
      console.error("Error generating title:", titleErr);
      new import_obsidian3.Notice("Error generating title: " + titleErr.message);
      return null;
    }
  }
  async sendAudioData(blob, fileName) {
    if (this.plugin.settings.useSilenceRemoval) {
      fileName = fileName.replace(/\.[^/.]+$/, ".wav");
      console.log("Using WAV filename:", fileName);
    }
    if (this.plugin.settings.debugMode) {
      console.log("Processing audio:", fileName);
      console.log("Audio format:", blob.type);
      console.log("Audio size:", blob.size);
    }
    try {
      const formData = new FormData();
      formData.append("file", blob, fileName);
      formData.append("model", this.plugin.settings.model);
      formData.append("language", this.plugin.settings.language);
      if (this.plugin.settings.prompt) {
        formData.append("prompt", this.plugin.settings.prompt);
      }
      const whisperResponse = await axios_default.post(
        this.plugin.settings.apiUrl,
        formData,
        {
          headers: {
            "Content-Type": "multipart/form-data",
            Authorization: `Bearer ${this.plugin.settings.whisperApiKey}`
          }
        }
      ).catch((error) => {
        if (error.response) {
          console.error("API Error Response:", {
            status: error.response.status,
            statusText: error.response.statusText,
            data: error.response.data
          });
          throw new Error(`API Error (${error.response.status}): ${JSON.stringify(error.response.data)}`);
        } else if (error.request) {
          console.error("No response received:", error.request);
          throw new Error("No response received from API");
        } else {
          console.error("Error setting up request:", error.message);
          throw error;
        }
      });
      let finalText = whisperResponse.data.text;
      const originalText = finalText;
      if (this.plugin.settings.usePostProcessing && this.plugin.settings.postProcessingModel) {
        if (this.plugin.settings.debugMode) {
          new import_obsidian3.Notice("Post-processing transcription...");
        }
        try {
          let postProcessResponse;
          const isAnthropicModel = this.plugin.settings.postProcessingModel.startsWith("claude");
          if (isAnthropicModel) {
            if (!this.plugin.settings.anthropicApiKey) {
              throw new Error("Anthropic API key is required for Claude models");
            }
            postProcessResponse = await axios_default.post(
              "https://api.anthropic.com/v1/messages",
              {
                model: this.plugin.settings.postProcessingModel,
                max_tokens: 8190,
                messages: [
                  {
                    role: "user",
                    content: this.plugin.settings.postProcessingPrompt + "\n\n" + finalText
                  }
                ]
              },
              {
                headers: {
                  "Content-Type": "application/json",
                  "x-api-key": this.plugin.settings.anthropicApiKey,
                  "anthropic-version": "2023-06-01",
                  "anthropic-dangerous-direct-browser-access": "true"
                }
              }
            );
            finalText = postProcessResponse.data.content[0].text;
          } else {
            postProcessResponse = await axios_default.post(
              "https://api.openai.com/v1/chat/completions",
              {
                model: this.plugin.settings.postProcessingModel,
                messages: [
                  {
                    role: "system",
                    content: this.plugin.settings.postProcessingPrompt
                  },
                  {
                    role: "user",
                    content: finalText
                  }
                ],
                temperature: 0.7
              },
              {
                headers: {
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${this.plugin.settings.openAiApiKey}`
                }
              }
            );
            finalText = postProcessResponse.data.choices[0].message.content.trim();
          }
          if (this.plugin.settings.debugMode) {
            new import_obsidian3.Notice("Post-processing complete.");
          }
        } catch (postErr) {
          console.error("Error during post-processing:", postErr);
          new import_obsidian3.Notice("Error during post-processing: " + postErr.message);
        }
      }
      return { transcription: finalText, originalText };
    } catch (err) {
      console.error("Error processing audio:", err);
      new import_obsidian3.Notice("Error processing audio: " + err.message);
      throw err;
    }
  }
  /**
   * Convert a Blob to base64 string
   */
  blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        if (typeof reader.result === "string") {
          const base64 = reader.result.includes("base64,") ? reader.result.split("base64,")[1] : reader.result;
          resolve(base64);
        } else {
          reject(new Error("Failed to convert blob to base64"));
        }
      };
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
  /**
   * Convert AudioBuffer to WAV format
   */
  audioBufferToWav(buffer) {
    const numOfChan = buffer.numberOfChannels;
    const length = buffer.length * numOfChan * 2;
    const buffer1 = new ArrayBuffer(44 + length);
    const view = new DataView(buffer1);
    if (this.plugin.settings.debugMode) {
      console.log("Creating WAV with:", {
        numberOfChannels: numOfChan,
        sampleRate: buffer.sampleRate,
        length,
        totalSize: 44 + length
      });
    }
    view.setUint8(0, 82);
    view.setUint8(1, 73);
    view.setUint8(2, 70);
    view.setUint8(3, 70);
    view.setUint32(4, 36 + length, true);
    view.setUint8(8, 87);
    view.setUint8(9, 65);
    view.setUint8(10, 86);
    view.setUint8(11, 69);
    view.setUint8(12, 102);
    view.setUint8(13, 109);
    view.setUint8(14, 116);
    view.setUint8(15, 32);
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, numOfChan, true);
    view.setUint32(24, buffer.sampleRate, true);
    view.setUint32(28, buffer.sampleRate * numOfChan * 2, true);
    view.setUint16(32, numOfChan * 2, true);
    view.setUint16(34, 16, true);
    view.setUint8(36, 100);
    view.setUint8(37, 97);
    view.setUint8(38, 116);
    view.setUint8(39, 97);
    view.setUint32(40, length, true);
    const channels = Array.from({ length: buffer.numberOfChannels }, (_, i) => buffer.getChannelData(i));
    let offset = 44;
    for (let i = 0; i < buffer.length; i++) {
      for (let channel = 0; channel < numOfChan; channel++) {
        let sample = Math.max(-1, Math.min(1, channels[channel][i]));
        sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;
        view.setInt16(offset, sample, true);
        offset += 2;
      }
    }
    if (this.plugin.settings.debugMode) {
      const header = new Uint8Array(buffer1.slice(0, 44));
      console.log("WAV header check:", {
        ascii: Array.from(header).map((b) => String.fromCharCode(b)).join(""),
        hex: Array.from(header).map((b) => b.toString(16).padStart(2, "0")).join(" ")
      });
    }
    return Promise.resolve(new Blob([buffer1], { type: "audio/wav" }));
  }
  /**
   * Helper to get first n bytes of a blob for debugging
   */
  async getFirstBytes(blob, n) {
    const buffer = await blob.slice(0, n).arrayBuffer();
    return Array.from(new Uint8Array(buffer)).map((b) => b.toString(16).padStart(2, "0")).join(" ");
  }
  /**
   * Process audio buffer to remove silence
   */
  async removeSilence(buffer) {
    return buffer.getChannelData(0);
  }
  /**
   * Delete all transcripts from AssemblyAI
   * Note: We use Node.js https module directly instead of the AssemblyAI SDK because
   * the SDK's delete method uses browser's fetch API which triggers CORS preflight checks.
   * Since we're in Electron (Obsidian), using Node.js https module bypasses these CORS restrictions.
   */
  async deleteAllTranscripts() {
    var _a2;
    try {
      const { count, deleteAll } = await this.promptForDeletionCount();
      if (!count && !deleteAll) {
        return;
      }
      this.initializeAssemblyAI();
      if (!this.assemblyClient) {
        throw new Error("Failed to initialize AssemblyAI client");
      }
      let transcriptsToDelete = [];
      let previousPageUrl = null;
      let totalFound = 0;
      do {
        if (this.plugin.settings.debugMode) {
          console.log("Fetching transcripts page...", { previousPageUrl });
        }
        const listParams = previousPageUrl || { limit: 100 };
        const page = await this.assemblyClient.transcripts.list(listParams);
        if (this.plugin.settings.debugMode) {
          console.log("Raw transcript list:", page);
        }
        let pageTranscripts = [];
        if (Array.isArray(page)) {
          pageTranscripts = page.filter((t) => t && typeof t === "object" && "id" in t && typeof t.id === "string" && t.id.length > 0);
        } else if (page && typeof page === "object" && "transcripts" in page) {
          pageTranscripts = page.transcripts.filter((t) => t && typeof t === "object" && "id" in t && typeof t.id === "string" && t.id.length > 0);
        }
        transcriptsToDelete = transcriptsToDelete.concat(pageTranscripts);
        totalFound += pageTranscripts.length;
        if (this.plugin.settings.debugMode) {
          console.log(`Found ${pageTranscripts.length} valid transcripts on current page`);
        }
        previousPageUrl = ((_a2 = page.page_details) == null ? void 0 : _a2.prev_url) || null;
        if (!deleteAll && totalFound >= (count || 0)) {
          break;
        }
      } while (previousPageUrl !== null);
      if (!deleteAll && count) {
        transcriptsToDelete = transcriptsToDelete.slice(0, count);
      }
      if (transcriptsToDelete.length === 0) {
        new import_obsidian3.Notice("No valid transcripts found to delete");
        return;
      }
      for (const transcript of transcriptsToDelete) {
        try {
          if (this.plugin.settings.debugMode) {
            console.log(`Testing GET request for transcript: ${transcript.id}`);
          }
          const transcriptDetails = await this.assemblyClient.transcripts.get(transcript.id);
          if (this.plugin.settings.debugMode) {
            console.log(`Successfully retrieved transcript details:`, transcriptDetails);
          }
          if (this.plugin.settings.debugMode) {
            console.log(`Attempting to delete transcript: ${transcript.id}`);
          }
          await new Promise((resolve, reject) => {
            const options = {
              hostname: "api.assemblyai.com",
              port: 443,
              path: `/v2/transcript/${transcript.id}`,
              method: "DELETE",
              headers: {
                "Authorization": this.plugin.settings.assemblyAiApiKey
              }
            };
            const req = https.request(options, (res) => {
              if (res.statusCode === 200 || res.statusCode === 204) {
                resolve();
              } else {
                reject(new Error(`Failed to delete transcript: ${res.statusCode}`));
              }
            });
            req.on("error", (error) => {
              reject(error);
            });
            req.end();
          });
          if (this.plugin.settings.debugMode) {
            console.log(`Successfully deleted transcript: ${transcript.id}`);
          }
        } catch (deleteError) {
          console.error(`Error with transcript ${transcript.id}:`, deleteError);
        }
      }
      new import_obsidian3.Notice(`Successfully deleted ${transcriptsToDelete.length} transcripts`);
    } catch (error) {
      console.error("Error deleting transcripts:", error);
      new import_obsidian3.Notice(`Error deleting transcripts: ${error.message}`);
    }
  }
};

// src/WhisperSettingsTab.ts
var import_obsidian5 = require("obsidian");
var WhisperSettingsTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.settingsManager = plugin.settingsManager;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.containerEl.createEl("h2", { text: "API Keys" });
    this.createApiKeySettings();
    containerEl.createEl("h3", { text: "Transcription Service Settings" });
    new import_obsidian5.Setting(containerEl).setName("Transcription Service").setDesc("Choose which service to use for transcription").addDropdown((dropdown) => {
      dropdown.addOption("whisper", "Whisper").addOption("assemblyai", "AssemblyAI").setValue(this.plugin.settings.transcriptionService).onChange(async (value) => {
        this.plugin.settings.transcriptionService = value;
        await this.settingsManager.saveSettings(this.plugin.settings);
        this.display();
      });
    });
    new import_obsidian5.Setting(containerEl).setName("Prompt").setDesc("Words or phrases to help with transcription accuracy (comma-separated). For Whisper, this helps with correct spellings. For AssemblyAI, this boosts recognition of these terms.").addTextArea((text) => text.setPlaceholder("Enter words or phrases separated by commas").setValue(this.plugin.settings.prompt).onChange(async (value) => {
      this.plugin.settings.prompt = value;
      await this.settingsManager.saveSettings(this.plugin.settings);
    }));
    const whisperContainer = containerEl.createDiv();
    const assemblyAIContainer = containerEl.createDiv();
    whisperContainer.style.display = this.plugin.settings.transcriptionService === "whisper" ? "block" : "none";
    assemblyAIContainer.style.display = this.plugin.settings.transcriptionService === "assemblyai" ? "block" : "none";
    if (this.plugin.settings.transcriptionService === "whisper") {
      whisperContainer.createEl("h2", { text: "Whisper Settings" });
      this.createApiUrlSetting(whisperContainer);
      this.createModelSetting(whisperContainer);
      this.createLanguageSetting(whisperContainer);
    }
    if (this.plugin.settings.transcriptionService === "assemblyai") {
      assemblyAIContainer.createEl("h2", { text: "AssemblyAI Settings" });
      new import_obsidian5.Setting(assemblyAIContainer).setName("Model").setDesc("Choose which model to use for transcription").addDropdown((dropdown) => {
        dropdown.addOption("best", "Best Tier").addOption("nano", "Nano").setValue(this.plugin.settings.assemblyAiModel || "best").onChange(async (value) => {
          this.plugin.settings.assemblyAiModel = value;
          await this.settingsManager.saveSettings(this.plugin.settings);
        });
      });
      new import_obsidian5.Setting(assemblyAIContainer).setName("Word Boost Weight").setDesc("Control how much weight to apply to the boosted words/phrases").addDropdown((dropdown) => {
        dropdown.addOption("low", "Low").addOption("default", "Default").addOption("high", "High").setValue(this.plugin.settings.boostParam).onChange(async (value) => {
          this.plugin.settings.boostParam = value;
          await this.settingsManager.saveSettings(this.plugin.settings);
        });
      });
      new import_obsidian5.Setting(assemblyAIContainer).setName("AssemblyAI API Key").setDesc("Enter your AssemblyAI API key").addText((text) => text.setPlaceholder("Enter your AssemblyAI API key").setValue(this.plugin.settings.assemblyAiApiKey).onChange(async (value) => {
        this.plugin.settings.assemblyAiApiKey = value;
        await this.settingsManager.saveSettings(this.plugin.settings);
      }));
      new import_obsidian5.Setting(assemblyAIContainer).setName("Enable Speaker Diarization").setDesc("Identify and label different speakers in the transcription").addToggle((toggle) => toggle.setValue(this.plugin.settings.useSpeakerDiarization).onChange(async (value) => {
        this.plugin.settings.useSpeakerDiarization = value;
        await this.settingsManager.saveSettings(this.plugin.settings);
        this.display();
      }));
      if (this.plugin.settings.useSpeakerDiarization) {
        new import_obsidian5.Setting(assemblyAIContainer).setName("Expected Speaker Count").setDesc("Optional: Specify the expected number of speakers (leave empty for automatic detection)").addText((text) => {
          var _a2, _b2;
          return text.setPlaceholder("e.g., 2").setValue((_b2 = (_a2 = this.plugin.settings.speakerCount) == null ? void 0 : _a2.toString()) != null ? _b2 : "").onChange(async (value) => {
            const numValue = value ? parseInt(value) : void 0;
            this.plugin.settings.speakerCount = numValue;
            await this.settingsManager.saveSettings(this.plugin.settings);
          });
        });
      }
    }
    this.containerEl.createEl("h2", { text: "File Settings" });
    this.createSaveAudioFileToggleSetting();
    this.createSaveAudioFilePathSetting();
    this.createNewFileToggleSetting();
    this.createNewFilePathSetting();
    this.createDebugModeToggleSetting();
    containerEl.createEl("h3", { text: "Post-processing Settings with OpenAI/Claude" });
    new import_obsidian5.Setting(containerEl).setName("Use Post-Processing").setDesc("Use AI to clean up and format the transcription, including speaker name mapping for AssemblyAI").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.usePostProcessing).onChange(async (value) => {
        this.plugin.settings.usePostProcessing = value;
        await this.settingsManager.saveSettings(this.plugin.settings);
        this.display();
      })
    );
    if (this.plugin.settings.usePostProcessing) {
      new import_obsidian5.Setting(containerEl).setName("Post-Processing Model").setDesc("Select the model to use for post-processing").addDropdown(
        (dropdown) => dropdown.addOption("gpt-4o", "GPT-4o").addOption("gpt-4o-mini", "GPT-4o-mini").addOption("claude-3-5-sonnet-latest", "Claude 3.5 Sonnet").addOption("claude-3-5-haiku-latest", "Claude 3.5 Haiku").setValue(this.plugin.settings.postProcessingModel).onChange(async (value) => {
          this.plugin.settings.postProcessingModel = value;
          await this.settingsManager.saveSettings(this.plugin.settings);
          this.display();
        })
      );
      const isAnthropicModel = this.plugin.settings.postProcessingModel.startsWith("claude");
      if (isAnthropicModel) {
        new import_obsidian5.Setting(containerEl).setName("Anthropic API Key").setDesc("Your Anthropic API key for Claude models").addText(
          (text) => text.setPlaceholder("Enter your Anthropic API key").setValue(this.plugin.settings.anthropicApiKey).onChange(async (value) => {
            this.plugin.settings.anthropicApiKey = value;
            await this.settingsManager.saveSettings(this.plugin.settings);
          })
        );
      } else {
        new import_obsidian5.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key for GPT models").addText(
          (text) => text.setPlaceholder("Enter your OpenAI API key").setValue(this.plugin.settings.openAiApiKey).onChange(async (value) => {
            this.plugin.settings.openAiApiKey = value;
            await this.settingsManager.saveSettings(this.plugin.settings);
          })
        );
      }
      new import_obsidian5.Setting(containerEl).setName("Post-Processing Prompt").setDesc("The prompt to use for post-processing. For AssemblyAI transcripts, include instructions for mapping speaker labels to names.").addTextArea(
        (text) => text.setPlaceholder("Enter your post-processing prompt").setValue(this.plugin.settings.postProcessingPrompt).onChange(async (value) => {
          this.plugin.settings.postProcessingPrompt = value;
          await this.settingsManager.saveSettings(this.plugin.settings);
        })
      );
      new import_obsidian5.Setting(containerEl).setName("Keep Original Transcription").setDesc("Include the original transcription (before post-processing) in the output file").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.keepOriginalTranscription).onChange(async (value) => {
          this.plugin.settings.keepOriginalTranscription = value;
          await this.settingsManager.saveSettings(this.plugin.settings);
        })
      );
    }
    this.createSilenceRemovalSettings();
  }
  getUniqueFolders() {
    const files = this.app.vault.getMarkdownFiles();
    const folderSet = /* @__PURE__ */ new Set();
    for (const file of files) {
      const parentFolder = file.parent;
      if (parentFolder && parentFolder instanceof import_obsidian5.TFolder) {
        folderSet.add(parentFolder);
      }
    }
    return Array.from(folderSet);
  }
  createTextSetting(name, desc, placeholder, value, onChange) {
    new import_obsidian5.Setting(this.containerEl).setName(name).setDesc(desc).addText(
      (text) => text.setPlaceholder(placeholder).setValue(value).onChange(async (value2) => await onChange(value2))
    );
  }
  createApiKeySettings() {
    this.createTextSetting(
      "Whisper API Key",
      "Enter your API key for Whisper transcription (This can be the same as your OpenAI API key, but could also be a key to the groq-API or Microsoft Azure.)",
      "sk-...xxxx",
      this.plugin.settings.whisperApiKey,
      async (value) => {
        this.plugin.settings.whisperApiKey = value;
        await this.settingsManager.saveSettings(this.plugin.settings);
      }
    );
    this.createTextSetting(
      "OpenAI API Key",
      "Enter your OpenAI API key to use GPT models",
      "sk-...xxxx",
      this.plugin.settings.openAiApiKey,
      async (value) => {
        this.plugin.settings.openAiApiKey = value;
        await this.settingsManager.saveSettings(this.plugin.settings);
      }
    );
    this.createTextSetting(
      "Anthropic API Key",
      "Enter your Anthropic API key for Claude models",
      "sk-ant-...",
      this.plugin.settings.anthropicApiKey,
      async (value) => {
        this.plugin.settings.anthropicApiKey = value;
        await this.settingsManager.saveSettings(this.plugin.settings);
      }
    );
  }
  createApiUrlSetting(container = this.containerEl) {
    new import_obsidian5.Setting(container).setName("API URL").setDesc("Specify the endpoint that will be used to make requests to").addText(
      (text) => text.setPlaceholder("https://api.your-custom-url.com").setValue(this.plugin.settings.apiUrl).onChange(async (value) => {
        this.plugin.settings.apiUrl = value;
        await this.settingsManager.saveSettings(this.plugin.settings);
      })
    );
  }
  createModelSetting(container = this.containerEl) {
    new import_obsidian5.Setting(container).setName("Model").setDesc("Specify the machine learning model to use for transcribing audio to text").addText(
      (text) => text.setPlaceholder("whisper-1").setValue(this.plugin.settings.model).onChange(async (value) => {
        this.plugin.settings.model = value;
        await this.settingsManager.saveSettings(this.plugin.settings);
      })
    );
  }
  createLanguageSetting(container = this.containerEl) {
    new import_obsidian5.Setting(container).setName("Language").setDesc("Specify the language of the message being whispered").addText(
      (text) => text.setPlaceholder("en").setValue(this.plugin.settings.language).onChange(async (value) => {
        this.plugin.settings.language = value;
        await this.settingsManager.saveSettings(this.plugin.settings);
      })
    );
  }
  createSaveAudioFileToggleSetting() {
    new import_obsidian5.Setting(this.containerEl).setName("Save recording").setDesc(
      "Turn on to save the audio file after sending it to the Whisper API"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.saveAudioFile).onChange(async (value) => {
        this.plugin.settings.saveAudioFile = value;
        if (!value) {
          this.plugin.settings.saveAudioFilePath = "";
        }
        await this.settingsManager.saveSettings(
          this.plugin.settings
        );
        this.saveAudioFileInput.setDisabled(!value);
      })
    );
  }
  createSaveAudioFilePathSetting() {
    this.saveAudioFileInput = new import_obsidian5.Setting(this.containerEl).setName("Recordings folder").setDesc(
      "Specify the path in the vault where to save the audio files"
    ).addText(
      (text) => text.setPlaceholder("Example: folder/audio").setValue(this.plugin.settings.saveAudioFilePath).onChange(async (value) => {
        this.plugin.settings.saveAudioFilePath = value;
        await this.settingsManager.saveSettings(
          this.plugin.settings
        );
      })
    ).setDisabled(!this.plugin.settings.saveAudioFile);
  }
  createNewFileToggleSetting() {
    new import_obsidian5.Setting(this.containerEl).setName("Save transcription").setDesc(
      "Turn on to create a new file for each recording, or leave off to add transcriptions at your cursor"
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.createNewFileAfterRecording).onChange(async (value) => {
        this.plugin.settings.createNewFileAfterRecording = value;
        if (!value) {
          this.plugin.settings.createNewFileAfterRecordingPath = "";
        }
        await this.settingsManager.saveSettings(
          this.plugin.settings
        );
        this.createNewFileInput.setDisabled(!value);
      });
    });
  }
  createNewFilePathSetting() {
    this.createNewFileInput = new import_obsidian5.Setting(this.containerEl).setName("Transcriptions folder").setDesc(
      "Specify the path in the vault where to save the transcription files"
    ).addText((text) => {
      text.setPlaceholder("Example: folder/note").setValue(
        this.plugin.settings.createNewFileAfterRecordingPath
      ).onChange(async (value) => {
        this.plugin.settings.createNewFileAfterRecordingPath = value;
        await this.settingsManager.saveSettings(
          this.plugin.settings
        );
      });
    });
  }
  createDebugModeToggleSetting() {
    new import_obsidian5.Setting(this.containerEl).setName("Debug Mode").setDesc(
      "Turn on to increase the plugin's verbosity for troubleshooting."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
        this.plugin.settings.debugMode = value;
        await this.settingsManager.saveSettings(
          this.plugin.settings
        );
      });
    });
  }
  createSilenceRemovalSettings() {
    this.containerEl.createEl("h2", { text: "Silence Removal Settings" });
    this.containerEl.createEl("p", {
      text: "Note: If Remove Silence is enabled, the final audio will be saved as a WAV file."
    });
    new import_obsidian5.Setting(this.containerEl).setName("Remove Silence").setDesc("Remove silence from audio before processing (final file will be WAV).").addToggle((toggle) => toggle.setValue(this.plugin.settings.useSilenceRemoval).onChange(async (value) => {
      this.plugin.settings.useSilenceRemoval = value;
      await this.settingsManager.saveSettings(this.plugin.settings);
    }));
    new import_obsidian5.Setting(this.containerEl).setName("Silence Threshold").setDesc("Sound level (in dB) below which audio is considered silence. Lower values are more aggressive (-50 is default)").addSlider((slider) => slider.setLimits(-70, -5, 1).setValue(this.plugin.settings.silenceThreshold).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.silenceThreshold = value;
      await this.settingsManager.saveSettings(this.plugin.settings);
    }));
    new import_obsidian5.Setting(this.containerEl).setName("Minimum Silence Duration").setDesc("Minimum duration (in seconds) of silence to remove").addSlider((slider) => slider.setLimits(0.05, 10, 0.1).setValue(this.plugin.settings.silenceDuration).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.silenceDuration = value;
      await this.settingsManager.saveSettings(this.plugin.settings);
    }));
    new import_obsidian5.Setting(this.containerEl).setName("Remove All Silence").setDesc("When enabled, removes all silent periods throughout the audio. When disabled, only removes leading and trailing silence.").addToggle((toggle) => toggle.setValue(this.plugin.settings.silenceRemoveAll).onChange(async (value) => {
      this.plugin.settings.silenceRemoveAll = value;
      await this.settingsManager.saveSettings(this.plugin.settings);
    }));
  }
};

// src/SettingsManager.ts
var DEFAULT_SETTINGS = {
  whisperApiKey: "",
  openAiApiKey: "",
  anthropicApiKey: "",
  apiUrl: "https://api.openai.com/v1/audio/transcriptions",
  model: "whisper-1",
  prompt: "",
  language: "en",
  saveAudioFile: true,
  saveAudioFilePath: "",
  debugMode: false,
  createNewFileAfterRecording: true,
  createNewFileAfterRecordingPath: "",
  // Set defaults for new settings
  usePostProcessing: false,
  postProcessingPrompt: "",
  postProcessingModel: "gpt-4o",
  autoGenerateTitle: true,
  titleGenerationPrompt: "You are an intelligent bureaucratic assistant. You are tasked with generating a short (1-5 words), precise title for the TEXT below. Reply only with the title, nothing else. Generate the title in the main language of the TEXT. TEXT:",
  keepOriginalTranscription: false,
  // Default silence removal settings
  useSilenceRemoval: false,
  silenceThreshold: -30,
  silenceDuration: 2,
  silenceRemoveAll: true,
  transcriptionService: "whisper",
  assemblyAiApiKey: "",
  useSpeakerDiarization: false,
  speakerCount: void 0,
  wordBoost: [],
  // Default to empty array
  assemblyAiModel: "best",
  boostParam: "default"
  // Default boost parameter
};
var SettingsManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async loadSettings() {
    return Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.plugin.loadData()
    );
  }
  async saveSettings(settings) {
    await this.plugin.saveData(settings);
  }
};

// src/AudioRecorder.ts
var import_obsidian6 = require("obsidian");
function getSupportedMimeType() {
  const mimeTypes = ["audio/mp3", "audio/mp4", "audio/webm", "audio/ogg"];
  for (const mimeType of mimeTypes) {
    if (MediaRecorder.isTypeSupported(mimeType)) {
      return mimeType;
    }
  }
  return void 0;
}
var NativeAudioRecorder = class {
  constructor(plugin) {
    this.chunks = [];
    this.recorder = null;
    this.plugin = plugin;
    this.chunks = [];
    this.recorder = null;
  }
  /**
   * Minimal AudioContext-based silence removal.
   * - Decodes the Blob into a Float32 PCM array.
   * - Finds where amplitude is above a threshold.
   * - Trims leading and trailing silence.
   * - Re-encodes trimmed buffer as WAV.
   */
  async removeSilence(inputBlob) {
    if (!this.plugin.settings.useSilenceRemoval) {
      if (this.plugin.settings.debugMode) {
        console.log("Silence removal disabled, returning original audio");
      }
      return inputBlob;
    }
    try {
      const audioCtx = new AudioContext();
      const arrayBuffer = await inputBlob.arrayBuffer();
      const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
      const threshold = Math.pow(10, this.plugin.settings.silenceThreshold / 20);
      const inputData = audioBuffer.getChannelData(0);
      let maxDb = -Infinity;
      let minDb = Infinity;
      let sumDb = 0;
      let samplesAboveThreshold = 0;
      for (let i = 0; i < inputData.length; i++) {
        const amplitude = Math.abs(inputData[i]);
        if (amplitude > 0) {
          const db = 20 * Math.log10(amplitude);
          maxDb = Math.max(maxDb, db);
          minDb = Math.min(minDb, db);
          sumDb += db;
          if (amplitude > threshold) {
            samplesAboveThreshold++;
          }
        }
      }
      console.log(`Audio Statistics:
				Threshold: ${this.plugin.settings.silenceThreshold} dB
				Max Level: ${maxDb.toFixed(2)} dB
				Min Level: ${minDb.toFixed(2)} dB
				Avg Level: ${(sumDb / inputData.length).toFixed(2)} dB
				Samples Above Threshold: ${samplesAboveThreshold} of ${inputData.length}
				(${(samplesAboveThreshold / inputData.length * 100).toFixed(2)}%)`);
      if (this.plugin.settings.silenceRemoveAll) {
        const minSilenceSamples = this.plugin.settings.silenceDuration * audioBuffer.sampleRate;
        const shortSilenceSamples = Math.floor(0.5 * audioBuffer.sampleRate);
        const segments = [];
        let isInSilence = true;
        let silenceStart = 0;
        let nonSilenceStart = 0;
        for (let i = 0; i < inputData.length; i++) {
          if (isInSilence) {
            if (Math.abs(inputData[i]) > threshold) {
              if (i - silenceStart >= minSilenceSamples) {
                segments.push({ start: silenceStart, end: i, isSilence: true });
              }
              nonSilenceStart = i;
              isInSilence = false;
            }
          } else {
            if (Math.abs(inputData[i]) <= threshold) {
              silenceStart = i;
              if (nonSilenceStart < silenceStart) {
                segments.push({ start: nonSilenceStart, end: silenceStart, isSilence: false });
              }
              isInSilence = true;
            }
          }
        }
        if (!isInSilence && nonSilenceStart < inputData.length) {
          segments.push({ start: nonSilenceStart, end: inputData.length, isSilence: false });
        } else if (isInSilence && silenceStart < inputData.length) {
          segments.push({ start: silenceStart, end: inputData.length, isSilence: true });
        }
        const totalLength = segments.reduce((sum, seg) => sum + (seg.isSilence ? shortSilenceSamples : seg.end - seg.start), 0);
        if (totalLength === 0) {
          console.log("Audio is all silence or below threshold.");
          return inputBlob;
        }
        const trimmedBuffer = audioCtx.createBuffer(
          audioBuffer.numberOfChannels,
          totalLength,
          audioBuffer.sampleRate
        );
        for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
          const channelData = new Float32Array(totalLength);
          let writePos = 0;
          for (const segment of segments) {
            if (segment.isSilence) {
              for (let i = 0; i < shortSilenceSamples; i++) {
                channelData[writePos + i] = 0;
              }
              writePos += shortSilenceSamples;
            } else {
              const segmentData = audioBuffer.getChannelData(ch).slice(segment.start, segment.end);
              channelData.set(segmentData, writePos);
              writePos += segmentData.length;
            }
          }
          trimmedBuffer.copyToChannel(channelData, ch, 0);
        }
        const originalDuration = audioBuffer.length / audioBuffer.sampleRate;
        const newDuration = totalLength / audioBuffer.sampleRate;
        console.log(`Compressed silence in audio from ${originalDuration.toFixed(1)}s to ${newDuration.toFixed(1)}s`);
        new import_obsidian6.Notice(`Compressed ${segments.filter((s) => s.isSilence).length} silence segments from ${originalDuration.toFixed(1)}s to ${newDuration.toFixed(1)}s`);
        return await this.encodeWAV(trimmedBuffer);
      } else {
        let startIndex = 0;
        let endIndex = audioBuffer.length - 1;
        while (startIndex < audioBuffer.length) {
          if (Math.abs(inputData[startIndex]) > threshold) {
            console.log(`Found start of audio at ${startIndex} samples (${(startIndex / audioBuffer.sampleRate).toFixed(2)}s)`);
            break;
          }
          startIndex++;
        }
        while (endIndex > startIndex) {
          if (Math.abs(inputData[endIndex]) > threshold) {
            console.log(`Found end of audio at ${endIndex} samples (${(endIndex / audioBuffer.sampleRate).toFixed(2)}s)`);
            break;
          }
          endIndex--;
        }
        if (startIndex >= endIndex) {
          console.log("Audio is all silence or below threshold.");
          return inputBlob;
        }
        const trimmedLength = endIndex - startIndex + 1;
        const trimmedBuffer = audioCtx.createBuffer(
          audioBuffer.numberOfChannels,
          trimmedLength,
          audioBuffer.sampleRate
        );
        for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
          const channelData = audioBuffer.getChannelData(ch).slice(startIndex, endIndex + 1);
          trimmedBuffer.copyToChannel(channelData, ch, 0);
        }
        const removedSeconds = (audioBuffer.length - trimmedLength) / audioBuffer.sampleRate;
        console.log(`Removed ${removedSeconds.toFixed(1)} seconds of leading/trailing silence`);
        new import_obsidian6.Notice(`Removed ${removedSeconds.toFixed(1)} seconds of leading/trailing silence`);
        return await this.encodeWAV(trimmedBuffer);
      }
    } catch (error) {
      console.error("AudioContext processing error:", error);
      new import_obsidian6.Notice("Error processing audio: " + error);
      return inputBlob;
    }
  }
  getRecordingState() {
    var _a2;
    return (_a2 = this.recorder) == null ? void 0 : _a2.state;
  }
  getMimeType() {
    return this.mimeType;
  }
  async startRecording() {
    if (!this.recorder) {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: true
        });
        this.mimeType = getSupportedMimeType();
        if (!this.mimeType) {
          throw new Error("No supported mimeType found");
        }
        const options = { mimeType: this.mimeType };
        const recorder = new MediaRecorder(stream, options);
        recorder.addEventListener("dataavailable", (e) => {
          console.log("dataavailable", e.data.size);
          this.chunks.push(e.data);
        });
        this.recorder = recorder;
      } catch (err) {
        new import_obsidian6.Notice("Error initializing recorder: " + err);
        console.error("Error initializing recorder:", err);
        return;
      }
    }
    this.recorder.start(100);
  }
  async pauseRecording() {
    if (!this.recorder) {
      return;
    }
    if (this.recorder.state === "recording") {
      this.recorder.pause();
    } else if (this.recorder.state === "paused") {
      this.recorder.resume();
    }
  }
  async stopRecording() {
    return new Promise((resolve) => {
      if (!this.recorder || this.recorder.state === "inactive") {
        const blob = new Blob(this.chunks, { type: this.mimeType });
        this.chunks.length = 0;
        this.removeSilence(blob).then(resolve);
      } else {
        this.recorder.addEventListener(
          "stop",
          async () => {
            const blob = new Blob(this.chunks, {
              type: this.mimeType
            });
            this.chunks.length = 0;
            if (this.recorder) {
              this.recorder.stream.getTracks().forEach((track) => track.stop());
              this.recorder = null;
            }
            const processedBlob = await this.removeSilence(blob);
            resolve(processedBlob);
          },
          { once: true }
        );
        this.recorder.stop();
      }
    });
  }
  /**
   * Utility: Re-encode an AudioBuffer as a 16-bit .wav Blob.
   * Because we're not using ffmpeg, we'll produce a basic WAV format.
   * If you need MP3, you'd have to add a separate encoder library.
   */
  async encodeWAV(buffer) {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const format = 1;
    const bitsPerSample = 16;
    const channelData = [];
    const length = buffer.length * numChannels * 2;
    for (let i = 0; i < numChannels; i++) {
      channelData.push(buffer.getChannelData(i));
    }
    const bufferSize = 44 + length;
    const wavBuffer = new ArrayBuffer(bufferSize);
    const view = new DataView(wavBuffer);
    this.writeString(view, 0, "RIFF");
    view.setUint32(4, 36 + length, true);
    this.writeString(view, 8, "WAVE");
    this.writeString(view, 12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, format, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * numChannels * bitsPerSample / 8, true);
    view.setUint16(32, numChannels * bitsPerSample / 8, true);
    view.setUint16(34, bitsPerSample, true);
    this.writeString(view, 36, "data");
    view.setUint32(40, length, true);
    let offset = 44;
    for (let i = 0; i < buffer.length; i++) {
      for (let ch = 0; ch < numChannels; ch++) {
        const sample = channelData[ch][i];
        const clamped = Math.max(-1, Math.min(1, sample));
        view.setInt16(offset, clamped < 0 ? clamped * 32768 : clamped * 32767, true);
        offset += 2;
      }
    }
    return new Blob([wavBuffer], { type: "audio/wav" });
  }
  writeString(view, offset, text) {
    for (let i = 0; i < text.length; i++) {
      view.setUint8(offset + i, text.charCodeAt(i));
    }
  }
};

// main.ts
var Whisper = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.controls = null;
  }
  async onload() {
    this.settingsManager = new SettingsManager(this);
    this.settings = await this.settingsManager.loadSettings();
    this.addRibbonIcon("activity", "Open recording controls", (evt) => {
      if (!this.controls) {
        this.controls = new Controls(this);
      }
      this.controls.open();
    });
    this.addSettingTab(new WhisperSettingsTab(this.app, this));
    this.timer = new Timer();
    this.audioHandler = new AudioHandler(this);
    this.recorder = new NativeAudioRecorder(this);
    this.statusBar = new StatusBar(this);
    this.addCommands();
  }
  onunload() {
    if (this.controls) {
      this.controls.close();
    }
    this.statusBar.remove();
  }
  addCommands() {
    this.addCommand({
      id: "start-stop-recording",
      name: "Start/stop recording",
      callback: async () => {
        var _a2;
        if (this.statusBar.status !== "recording" /* Recording */) {
          this.statusBar.updateStatus("recording" /* Recording */);
          await this.recorder.startRecording();
        } else {
          this.statusBar.updateStatus("processing" /* Processing */);
          const audioBlob = await this.recorder.stopRecording();
          const extension = (_a2 = this.recorder.getMimeType()) == null ? void 0 : _a2.split("/")[1];
          const fileName = generateTimestampedFileName(extension);
          await this.audioHandler.processAudioChunks(audioBlob, fileName);
          this.statusBar.updateStatus("idle" /* Idle */);
        }
      },
      hotkeys: [
        {
          modifiers: ["Alt"],
          key: "Q"
        }
      ]
    });
    this.addCommand({
      id: "pause-resume-recording",
      name: "Pause/resume recording",
      callback: async () => {
        if (this.statusBar.status === "recording" /* Recording */) {
          await this.recorder.pauseRecording();
          this.statusBar.updateStatus("paused" /* Paused */);
        } else if (this.statusBar.status === "paused" /* Paused */) {
          await this.recorder.pauseRecording();
          this.statusBar.updateStatus("recording" /* Recording */);
        }
      },
      hotkeys: [
        {
          modifiers: ["Alt"],
          key: "W"
        }
      ]
    });
    this.addCommand({
      id: "upload-audio-file",
      name: "Upload audio file",
      callback: () => {
        const fileInput = document.createElement("input");
        fileInput.type = "file";
        fileInput.accept = "audio/*";
        fileInput.onchange = async (event) => {
          const files = event.target.files;
          if (files && files.length > 0) {
            const file = files[0];
            const fileName = file.name;
            await this.audioHandler.processAudioChunks(file, fileName);
          }
        };
        fileInput.click();
      }
    });
    this.addCommand({
      id: "delete-all-transcripts",
      name: "Delete all AssemblyAI transcripts",
      callback: async () => {
        if (this.settings.transcriptionService !== "assemblyai") {
          new import_obsidian7.Notice("This command is only available when using AssemblyAI as the transcription service");
          return;
        }
        await this.audioHandler.deleteAllTranscripts();
      }
    });
  }
};
